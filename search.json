[{"title":"go类内实现","path":"/2023/02/07/go类内实现/","content":"o类内实现 | 笔记整理! 封装基本操作123456789101112131415161718192021222324252627282930313233package main import &quot;fmt&quot; // Person类 绑定方法:eat run laugh 成员 type Person struct &#123; name string age int gender string score float64 &#125; // 在外边绑定方法 +()func (this *Person) Eat() &#123; fmt.Println(&quot;Person is eating&quot;) fmt.Println(this.name + &quot; is eating !&quot;) this.name = &quot;yongen&quot; fmt.Println(this.name + &quot; is eating !&quot;) &#125; func (this Person) Eat2() &#123; // 指针才会改编数据 单纯赋值是不会修改的原数据的 fmt.Println(&quot;Person is eating&quot;) fmt.Println(this.name + &quot; is eating !&quot;) this.name = &quot;yongen&quot; fmt.Println(this.name + &quot; is eating !&quot;) &#125; func main() &#123; yasuo := Person&#123;&quot;yasuo&quot;, 30, &quot;male&quot;, 100&#125; fmt.Println(yasuo) yasuo.Eat() fmt.Println(yasuo) &#125; 继承基本操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546package main import &quot;fmt&quot; type Person struct &#123; name string age int gender string score float64 &#125; // 嵌套一个 persontype Std struct &#123; per Person school string &#125; // 继承是直接来写就行 没有字段名字 type Teacher struct &#123; Person subject string &#125; func (this *Person) Eat() &#123; fmt.Println(&quot;I&#x27;m ,&quot;, this.name) &#125; func main() &#123; s1 := Std&#123; per: Person&#123;&quot;yasuo&quot;, 16, &quot;male&quot;, 100&#125;, school: &quot;aiouniya&quot;, &#125; fmt.Println(s1.per, s1.school) // 继承 // 可以这样来操作 //t1 := Teacher&#123; // Person: Person&#123;&quot;yongen&quot;, 18, &quot;male&quot;, 100&#125;, // subject: &quot;Chinese&quot;, //&#125; t1 := Teacher&#123;&#125; t1.subject = &quot;Math&quot; t1.name = &quot;ikun&quot; t1.Eat() // 特殊用法 // 继承的时候 我们没有定义字段名字 但是会创建一个同名字段 // 为了在自雷中依然可以操作父类 因为子类父类可能出现同名的字段 fmt.Println(&quot;t1.Person.name&quot;, t1.Person.name) &#125; 访问权限文件树123456789文件夹 PATH 列表卷序列号为 4829-01C8C:.├─.idea├─class├─inherit└─polymorphic ├─.idea └─src src/fun.go12345678910111213141516171819202122232425package src import &quot;fmt&quot; type Person struct &#123; Name string Age int Gender string Score float64 &#125; // 嵌套一个 persontype Std struct &#123; Per Person School string &#125; // 继承是直接来写就行 没有字段名字 type Teacher struct &#123; Person Subject string &#125; func (this *Person) Eat() &#123; fmt.Println(&quot;I&#x27;m ,&quot;, this.Name) &#125; main.go1234567891011121314151617181920212223242526package main import ( &quot;fmt&quot; &quot;polymorphic/src&quot;) func main() &#123; s1 := src.Std&#123; Per: src.Person&#123;&quot;yasuo&quot;, 16, &quot;male&quot;, 100&#125;, School: &quot;aiouniya&quot;, &#125; fmt.Println(s1.Per, s1.School) // 继承 // 可以这样来操作 //t1 := Teacher&#123; // Person: Person&#123;&quot;yongen&quot;, 18, &quot;male&quot;, 100&#125;, // subject: &quot;Chinese&quot;, //&#125; t1 := src.Teacher&#123;&#125; t1.Subject = &quot;Math&quot; t1.Name = &quot;ikun&quot; t1.Eat() // 特殊用法 // 继承的时候 我们没有定义字段名字 但是会创建一个同名字段 // 为了在自雷中依然可以操作父类 因为子类父类可能出现同名的字段 fmt.Println(&quot;t1.Person.name&quot;, t1.Person.Name) &#125; 多态前导知识 | interface1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package main import &quot;fmt&quot; // c++中实现接口 纯虚构函数代替接口 // go语言有专门的关键字 interface 来代替接口 // 不仅仅用于处理多态 介意接受任意的数据类型 类似于void func main() &#123; fmt.Println(&quot;&quot;) //定义 接口 var i, j, k interface&#123;&#125; name := []string&#123;&quot;yasuo&quot;, &quot;yongen&quot;&#125; i = name fmt.Println(&quot;i behalf of arr:&quot;, i) i2 := 20 age := i2 j = age fmt.Println(&quot;j behalf of num:&quot;, j) str := &quot;hello world&quot; k = str fmt.Println(&quot;k behalf of string:&quot;, k) // 我们现在只知道 k是 interface 但不知道他的明确类型 // 需要一种判断 --&gt;断言 value, ok := k.(int) if !ok &#123; fmt.Println(&quot;type is not int&quot;) &#125; else &#123; fmt.Println(&quot;key value is&quot;, value) &#125; // 使用场景 把 interface当做一个函数的参数 类似于 print ,使用switch 来判断用户输入的类型 // 根据类型 来进行处理 // 创建一个具有三个接口类型的切片 arr := make([]interface&#123;&#125;, 3) arr[0] = 10086 arr[1] = &quot;yasuo&quot; arr[2] = true for _, v := range arr &#123; // 可以去除当前接口真正数据类型 switch v := v.(type) &#123; case int: fmt.Println(&quot;type is int ,value is&quot;, v) case bool: fmt.Println(&quot;type is bool ,value is&quot;, v) case string: fmt.Println(&quot;type is string ,value is&quot;, v) default: fmt.Println(&quot;type is not find&quot;) &#125; &#125; &#125; 多态实现 定义一个接口 里面设计好需要的接口 (可以有多个)任何实现了这个接口的类型 都可以赋值给这个接口 从而实现多态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package main import &quot;fmt&quot; // 实现go多态 需要实现定义接口 // 注意类型是 interfacetype IAttack interface &#123; // 接口可以有多个 但只能有一个函数原型 Attack() &#125; // 低等级 type PersonLowLevel struct &#123; name string level int &#125; // 高等级 type PersonHighLevel struct &#123; name string level int &#125; func (a *PersonLowLevel) Attack() &#123; fmt.Println(&quot;I&#x27;m&quot;, a.name, &quot;and level is&quot;, a.level, &quot;causing harm&quot;, a.level*50) &#125; func (a *PersonHighLevel) Attack() &#123; fmt.Println(&quot;I&#x27;m&quot;, a.name, &quot;and level is&quot;, a.level, &quot;causing harm&quot;, a.level*90) &#125; // 定义一个多态的接口 传入不同的对象 调用同样的方法 func DoAttack(a IAttack) &#123; a.Attack() &#125; func main() &#123; var player IAttack // 空接口 lowLevel := PersonLowLevel&#123; name: &quot;yasuo&quot;, level: 1, &#125; lowLevel.Attack() // 对于player进行赋值 // 任何一个实现了接口的 都可以使用这个方法 // 接口需要通过指针进行赋值 player = &amp;lowLevel fmt.Println(player) player.Attack() highLevel := PersonHighLevel&#123; name: &quot;yongen&quot;, level: 10, &#125; //highLevel.Attack() player = &amp;highLevel highLevel.Attack() DoAttack(&amp;lowLevel) DoAttack(&amp;highLevel) &#125;","tags":["计算机","编程语言"],"categories":["编程语言","go"]},{"title":"go语言入门","path":"/2023/02/07/go语言入门/","content":"go语言入门 | 笔记整理! 基础部分变量12345678910111213// 变量赋值手法func test() &#123;\t// 1.定义\tvar name string\tname = &quot;yasuo&quot;\t// 2.定义时直接复制\tvar city = &quot;yasuo&quot;\t// 3.自动推导\tans := 100\t// 4.平行复制\ti, j := 10, 20\tfmt.Println(&quot;变量赋值手法! &quot;, name, city, ans, i, j)&#125; 自增自检12345678// 自增 自减 (必须单独一行)不支持三目运算符func test02() &#123;\ti := 20\ti++\tfmt.Println(&quot;i:&quot;, i)\ti--\tfmt.Println(&quot;i:&quot;, i)&#125; 指针12345678910111213141516171819202122232425262728// 可以返回栈上的指针func testPtr() *string &#123;\tname := &quot;yasuo&quot;\treturn &amp;name&#125;func main() &#123;\ttest()\ttest02()\t// 指针部分 (垃圾回收机制 开发人员不是过分需要手动释放内存\t// go支持返回栈上指针 (内存逃逸\t// 指针为空nil\t// 1.直接分配\tname := &quot;yasuo&quot;\tptr := &amp;name\tfmt.Println(&quot;name&quot;, ptr, *ptr)\t// 2.new进行分配\tnamePtr := new(string)\t*namePtr = &quot;yasuo&quot;\tfmt.Println(&quot;name&quot;, namePtr, *namePtr)\t// 3.栈上指针 返回 (编译器会进行操作的\tans := testPtr()\tif ans == nil &#123; fmt.Println(&quot;指针为空&quot;)\t&#125;\tfmt.Println(&quot;栈上指针:&quot;, ans, *ans)&#125; 不支持的操作 不支持++i,--i 不支持地址加减 不支持三目运算符 只有false才能代表代码逻辑为假,数字0和nil不支持 字符串1234567891011121314151617181920212223242526272829// 字符串func test3() &#123;\t// 1. 直接使用\tname := &quot;name&quot;\t// 2. 需要换行时候\tusage := `./a.out ./help ./play `\tfmt.Println(name, usage)\t// 3.长度和访问 没有length方法 有自由函数 len()\tl := len(name)\tfmt.Println(l)\t// 4.格式化输出\tfor i := 0; i &lt; len(name); i++ &#123; fmt.Printf(&quot;i:%d,v%c &quot;, i, name[i])\t&#125;\t// 5.字符串拼接\ti, j := &quot;libai&quot;, &quot;hanxin&quot;\tfmt.Println(&quot;i+j:&quot;, i+j)\t// 6.字符串比较\tfmt.Println(&quot;i&gt;j:&quot;, i &gt; j)&#125; 数组+ 切片数组1234567891011121314151617181920212223242526272829303132// 数组func test04() &#123;\t// 1.直接使用\tvar nums = [10]int&#123;1, 2, 3&#125;\tnum := [10]int&#123;1, 2, 3&#125;\tfmt.Println(nums, num)\t// 2. 不定长数组 使用make处理\t// 换种说法 为slice\tnames := []string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;安徽&quot;, &quot;四川&quot;&#125;\tfor k, v := range names &#123; fmt.Println(k, v)\t&#125;\t// 2.1 数组追加\t// 注意: 不仅是有长度的概念 也是有容量的概念\t// 会根据使用情况 + 2*现在长度内存\tnames1 := append(names, &quot;西安&quot;)\tnames1 = append(names1, &quot;西藏&quot;)\tfmt.Println(names, len(names), cap(names), &quot; &quot;, names1, len(names1), cap(names1))\t// 遍历处理方式\tfor i := 0; i &lt; len(nums); i++ &#123; fmt.Print(i, nums[i], &quot;\\t&quot;)\t&#125;\tfmt.Println()\t// 注意:修改v不会概念nums的值 nums[i]修改才会更改的!\t// 对于k,v只会存储一次 不断的进行重复赋值\tfor k, v := range nums &#123; fmt.Print(k, v, &quot;\\t&quot;)\t&#125;\t// 注意:如果想要忽略某一个值 可以用 _ 来占位忽略&#125; 切片123456789101112131415161718192021222324252627282930// 切片func test05() &#123;\tnames := [7]string&#123;&quot;yasuo&quot;, &quot;libai&quot;, &quot;hanxin&quot;, &quot;zhangfei&quot;, &quot;liubei&quot;, &quot;liubei&quot;&#125;\tnames1 := [3]string&#123;&#125;\tnames1[0] = names[0]\tnames1[1] = names[1]\tnames1[2] = names[2]\tfmt.Println(names1)\t// 切片选择就跟python用法差不多一致\t// 但只是浅拷贝\tnames2 := names[0:3]\tnames2[0] = &quot;wuzetian&quot;\tfmt.Println(names2, names)\t// 必须数据污染 可以进行 copy\tarr := make([]string, len(names))\tcopy(arr, names[:])\tfmt.Println(&quot;copy后的arr&quot;, arr)\t// 可以对于字符串进行切片截取: 取字符串的子串\the := &quot;hello world&quot;\tfmt.Println(&quot;sub&quot;, he[5:8])\t// 创建空切片 可以指定一下容量\tls := make([]int, 0, 20)\tfmt.Println(ls, len(ls), cap(ls))&#125; 字典123456789101112131415161718192021222324252627282930313233// 字典func test06() &#123;\t// 存储的是 key:value的映射关系\t// 1.基础使用\t// 需要分配内存 不然会出现\t// panic: assignment to entry in nil map\tvar idNames map[int]string\t// 2. 分配空间 可以分配长度\tidNames = make(map[int]string)\t// 3.可以直接 赋值推导\t// idNames := make(map[int]string)\tidNames[0] = &quot;yasuo&quot;\tidNames[1] = &quot;hanxin&quot;\t// 4.遍历map\tfor k, v := range idNames &#123; fmt.Println(k, v)\t&#125;\t// 判断key存在于map 不存在的话 会返回一个nil\t// 可以借助 第二个参数接受状态\tname3, err := idNames[3]\tfmt.Println(name3, err)\t// 5.删除数值\t// 通过自由函数 delete删除制定的key\tfmt.Println(idNames)\tdelete(idNames, 1)\tdelete(idNames, 100) // 删除不存在的不会报错\tfmt.Println(idNames)&#125; 函数1234567891011121314151617181920// 函数返回值 在参数列表之后// 如果有多个返回值 需要使用括号 进行包裹// 多个参数使用 , 分割func test(a int, b int, c string) (int, string, bool) &#123;\treturn a * b, c, true&#125;// 类型相同的话 可以连着一起操作// 当返回值 有名字的时候 可以直接简写returnfunc test1(a, b int, c string) (res int, str string, bl bool) &#123;\tres = a * b\tstr = c\tbl = true\treturn&#125;// 当返回值 只有一个参数 并且没有名字 不需要加圆括号func test2() int &#123;\treturn 10&#125; 内存逃逸12345678910func testptr() *string &#123;\tname := &quot;yasuo&quot;\tp0 := &amp;name\tfmt.Println(&quot;*po&quot;, *p0)\tcity := &quot;xicdan&quot;\tptr := &amp;city\treturn ptr&#125; 查看方法1go build -gcflags=&quot;-m -m -l&quot; 内存逃逸.go &gt;1.txt 2&gt;&amp;1 相关笔记[Go] 详解内存逃逸 - 掘金 import1234567891011121314151617181920// 如果函数是想被外部访问时候 函数开头要大写 相当于public// 内部是完全可以使用的package mainimport (\t&quot;awesomeProject/src/add&quot;\t//&quot;awesomeProject/src/sub&quot; // 常规导入模式\t//SUB &quot;awesomeProject/src/sub&quot; //类似于重命名\t. &quot;awesomeProject/src/sub&quot; //导入所有包\t&quot;fmt&quot;)func main() &#123;\tres := Sub(20, 10)\tfmt.Println(&quot;res:&quot;, res)\tret := add.Add(20, 20)\tfmt.Println(&quot;ret:&quot;, ret)&#125; 12345package subfunc Sub(a, b int) int &#123;\treturn a - b&#125; 12345package addfunc Add(a, b int) int &#123;\treturn a + b&#125; 目录形式1234567文件夹 PATH 列表卷序列号为 4829-01C8C:.├─.idea└─src ├─add └─sub GOLANG导入自己写的 包/函数_go引入自己的包_江枫霜的博客-CSDN博客 switch + os123456789101112131415161718192021222324252627282930package mainimport (\t&quot;fmt&quot;\t&quot;os&quot;)func main() &#123;\t// 命令行输入\t// c:argc,**argv\t// go:os.Args --&gt;build一下 命令行执行\tcmds := os.Args\t//for k, v := range cmds &#123;\t//\tfmt.Println(&quot;key&quot;, k, &quot;value&quot;, v, &quot;len&quot;, len(cmds))\t//&#125;\tif len(cmds) &lt; 2 &#123; fmt.Println(&quot;please input the arguments&quot;) return\t&#125;\tswitch cmds[1] &#123;\tcase &quot;hello&quot;: fmt.Println(&quot;hello world&quot;) fallthrough // 向下穿透\tcase &quot;world&quot;: fmt.Println(&quot;world hello&quot;)\tdefault: fmt.Println(&quot;hello yasuo&quot;)\t&#125;&#125; 条件控制语句12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123;\t// 标签 label1\t// goto label1 下一次进入循环时候 i不会保存之前的状态 重新从0开始\t// break label1 直接跳出当前循环\t// continue label1 下一下进入循环时候 会记录之前的状态label:\tfor i := 0; i &lt; 5; i++ &#123; for j := 0; j &lt; 5; j++ &#123; if j == 3 &#123; //goto label //continue label break label &#125; fmt.Println(&quot;i:&quot;, i, &quot;j:&quot;, j) &#125;\t&#125;\tfmt.Println(&quot;over&quot;)&#125; 枚举1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;// 模拟表示一周const ( Monday = iota Tuesday Wendesday Thursday Friday Saturday Sunday is_7, not_7 = iota, iota)func main() &#123; // go语言没有枚举类型 可以使用const + iota(常量累加器)模拟实现 // 每换行一次+1 (同一行的iota的数值都是一样的 // 不赋值的话 默认与上一行表达式一致 // 每一个iota是独立的 遇到const iota会重新清零 // 很多定义时候 //var num int //var name string //var flag bool // 使用变量组来统一定义 //var( // num int // name string // flag bool //) fmt.Println(Monday, Tuesday, Wendesday, Thursday, Friday, Saturday, Sunday) fmt.Println(is_7, not_7)&#125; 结构体12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;// c语言 重名 typedef int myInttype myInt int// Person go 语言结构体 type + structtype Person struct &#123; name string age int gender string score float64&#125;func main() &#123; var i, j myInt i, j = 10, 20 fmt.Println(&quot;i+j:&quot;, i+j) // 完全赋值的话 字段名可以不写 yasuo := Person&#123;&quot;yasuo&quot;, 18, &quot;male&quot;, 61&#125; //yasuo := Person&#123; // name: &quot;yasuo&quot;, // age: 18, // gender: &quot;male&quot;, // score: 61, //&#125; // 打印输出方式 fmt.Println(yasuo) ptr1 := &amp;yasuo fmt.Println((*ptr1).name, (*ptr1).age, (*ptr1).gender, (*ptr1).score) fmt.Println(yasuo.name, yasuo.age, yasuo.gender, yasuo.score) // 如果不完全赋值的话 必须指定变量名字 yongen := Person&#123; name: &quot;yongen&quot;, age: 64, &#125; //yongen := Person&#123;&quot;yongen&quot;, 64&#125; // 会报错 fmt.Println(yongen)&#125; init初始化123456789101112131415161718package subimport &quot;fmt&quot;// 1. init初始化函数 没有参数 没有返回值// 2. 一个包含多个init时 调用顺序不确定// 3. init函数是不允许用户显示调用的// 4. 有的时候引用一个包 可能只想使用这个包的 init函数的话 (例如mysql的初始化)// 不想使用其他函数 为了防止编译器报错 可以使用_来处理func init() &#123;\tfmt.Println(&quot;this is init() in package sub&quot;)&#125;func init() &#123;\tfmt.Println(&quot;this is second init() in package sub&quot;)&#125;func Sub(a, b int) int &#123;\treturn a - b&#125; 12345678910package mainimport ( _ &quot;init/sub&quot; // 不想使用其他函数 只想使用init 为了防止编译器报错 可以使用_来处理)func main() &#123; //res := sub.Sub(20, 10) //fmt.Println(&quot;sub.Sub(20,10)&quot;, res)&#125; defer123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;os&quot;)func readFile(filename string) &#123; fl, err := os.Open(filename) // 这样来写用到了 defer //defer fl.Close() // 也可以使用 匿名函数关闭文件 defer func() &#123; fmt.Println(&quot;will close file&quot;) _ = fl.Close() &#125;() if err != nil &#123; fmt.Println(&quot;file to open file:&quot;, filename) return &#125; buf := make([]byte, 1024) n, _ := fl.Read(buf) fmt.Println(&quot;len:&quot;, n, &quot;info:&quot;, string(buf)) defer fmt.Println(&quot;next defer statement&quot;) defer fmt.Println(&quot;last defer statement&quot;)&#125;func main() &#123; // 1. defer 延迟 关键字 用来修饰关键字 函数 在退出时候 一定会执行 // 2. 一般用于资源清理 // 3. 解锁和关闭文件 // 4. 在同一个函数中 多次调用defer 执行时 类似于stack // 多次defer语句 最后写的defer 先执行 stack特征 filename := &quot;base_go1/defer/test.txt&quot; readFile(filename)&#125;","tags":["计算机","编程语言"],"categories":["编程语言","go"]},{"title":"螺旋数组","path":"/2023/01/26/螺旋数组/","content":"螺旋矩阵 | 笔记整理! 破解模板 | 优化方位进行模拟 过于漫长! 1234567891011121314151617181920212223242526# 向左移动i,j=t,lwhile j&lt;=r and head: ls[i][j]=head.val head=head.next j+=1t+=1i,j=t,r# 向下走while i&lt;=d and head: ls[i][j]=head.val head=head.next i+=1r-=1i,j=d,rwhile j&gt;=l and head: ls[i][j]=head.val head=head.next j-=1d-=1i,j=d,lwhile i&gt;=t and head: ls[i][j]=head.val head=head.next i-=1l+=1 优化 | 坐标测试1234567891011121314ans=[[-1]*n for _ in range(m)]# 模拟右下左上d=[[0,1],[1,0],[0,-1],[-1,0]]idx=0cur=[0,0]while head: l,r=cur ans[l][r]=head.val i,j=d[idx] if not 0&lt;=l+i&lt;m or not 0&lt;=r+j&lt;n or ans[l+i][r+j]!=-1: idx=(idx+1)%4 i,j=d[idx] cur=[l+i,r+j] head=head.next 同类习题54.螺旋数组123456789101112131415161718192021class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: m,n=len(matrix),len(matrix[0]) ls=[(0,1),(1,0),(0,-1),(-1,0)] sz=m*n vis=[[1]*n for _ in range(m)] ans=[0]*sz cnt=[0,0] idx=0 ls_id=0 while idx&lt;sz: l,r=cnt ans[idx]=matrix[l][r] vis[l][r]=0 i,j=ls[ls_id] if not 0&lt;=l+i&lt;m or not 0&lt;=r+j&lt;n or vis[l+i][r+j]==0: ls_id=(ls_id+1)%4 i,j=ls[ls_id] cnt=[l+i,r+j] idx+=1 return ans 59.螺旋矩阵21234567891011121314151617181920class Solution: def generateMatrix(self, n: int) -&gt; List[List[int]]: ls=[(0,1),(1,0),(0,-1),(-1,0)] sz=n*n vis=[[1]*n for _ in range(n)] ans=[[1]*n for _ in range(n)] cnt=[0,0] idx=0 ls_id=0 while idx&lt;sz: l,r=cnt ans[l][r]=idx+1 vis[l][r]=0 i,j=ls[ls_id] if not 0&lt;=l+i&lt;n or not 0&lt;=r+j&lt;n or vis[l+i][r+j]==0: ls_id=(ls_id+1)%4 i,j=ls[ls_id] cnt=[l+i,r+j] idx+=1 return ans 885.螺旋矩阵3 思路有所参考 12345678910111213141516171819class Solution: def spiralMatrixIII(self, rows: int, cols: int, rs: int, cs: int) -&gt; List[List[int]]: d=[[0,1],[1,0],[0,-1],[-1,0]] idx=0 a,b=rs,cs ans=[[a,b]] step=0 while len(ans)&lt;rows*cols: i,j=d[idx] step+=1 for i in range(2): for j in range(step): l,r=d[idx] a+=l b+=r if 0&lt;=a&lt;rows and 0&lt;=b&lt;cols: ans.append([a,b]) idx=(idx+1)%4 return ans 2326.螺旋矩阵41234567891011121314151617class Solution: def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -&gt; List[List[int]]: ans=[[-1]*n for _ in range(m)] # 模拟右下左上 d=[[0,1],[1,0],[0,-1],[-1,0]] idx=0 cur=[0,0] while head: l,r=cur ans[l][r]=head.val i,j=d[idx] if not 0&lt;=l+i&lt;m or not 0&lt;=r+j&lt;n or ans[l+i][r+j]!=-1: idx=(idx+1)%4 i,j=d[idx] cur=[l+i,r+j] head=head.next return ans","tags":["算法学习"],"categories":["算法学习","数组","螺旋矩阵"]},{"path":"/2023/01/18/字符串匹配/","content":"字符串匹配笔记 | 笔记整理! 字符串匹配问题总结前置信息 | 初始化 | 传入信息123456789def __init__(self,strs,target) -&gt; None: self.s=strs self.t=target self.m=len(self.s) self.n=len(self.t) self.nxt=[0]*(self.n+1) self.nxtval=[0]*(self.n+1) 朴素匹配 | 逐个对比123456789101112131415def plain_match(self): ans=-1 for i in range(self.m-self.n+1): k=i flag=1 for j in range(self.n): if self.s[k]!=self.t[j]: flag=0 break else: k+=1 if flag: ans=i break return ans 字符串哈希 | 存在理论上失败的可能12345678910111213141516171819202122232425262728293031323334353637383940414243class BKDRHash(): def __init__(self,strs,target) -&gt; None: self.s=strs self.t=target self.m=len(self.s) self.n=len(self.t) self.pp=131 self.pre=[0]*self.m self.pattern_val=-1 self.ans=-1 # 求取匹配串的哈希数值 def get_v(self): for k,v in enumerate(self.t): cur=ord(v)-ord(&#x27;a&#x27;)+1 if k: self.pattern_val=self.pattern_val*self.pp+cur else: self.pattern_val=cur # 利用前缀哈希和 求取 def get_ans(self): for k,v in enumerate(self.s): cur=ord(v)-ord(&#x27;a&#x27;)+1 if k: self.pre[k]=self.pre[k-1]*self.pp+cur else: self.pre[k]=cur if k==self.n-1: if self.pre[k]==self.pattern_val: self.ans=0 break if k&gt;self.n-1: val=self.pre[k]-self.pre[k-self.n]*pow(self.pp,self.n) if self.pattern_val==val: self.ans=k+1-self.n break def run(self): self.get_v() self.get_ans() return self.ans kmp算法 | 求next nextval数组逻辑1234567891011121314151617181920212223242526272829303132333435363738def get_next(self): j=0 for i in range(1,self.n): while j and self.t[i]!=self.t[j]: j=self.nxt[j] if self.t[i]==self.t[j]: j+=1 self.nxt[i+1]=jdef get_nextval(self): j=0 for i in range(1,self.n): while j and self.t[i]!=self.t[j]: j=self.nxtval[j] if self.t[i]==self.t[j]: j+=1 self.nxtval[i+1]=j # 纯直接丑陋思路 | 没想到更好的 不过这样也不错! if self.t[self.nxtval[i]]==self.t[i]: self.nxtval[i]=self.nxtval[self.nxtval[i]]def get_key(self,nxt): ans=-1 j=0 for i in range(self.m): while j and self.s[i]!=self.t[j]: j=nxt[j] if self.s[i]==self.t[j]: j+=1 if j==self.n: ans=i+1-self.n break return ansdef get_key_bool(self,nxt): return self.get_key(nxt)!=-1 拓展kmp(Z)算法 | 不同写法0-base1234567891011121314151617# 拓展kmp算法! |def extend_kmp_1_base(self,s): l,r=1,0 s=&#x27;0&#x27;+s n=len(s) z=[0]*(n) for i in range(2,n): if i&gt;r: z[i]=0 else: k=i-l+1 z[i]=min(z[k],r-i+1) while i+z[i]&lt;n and s[i+z[i]]==s[1+z[i]]: z[i]+=1 if i+z[i]-1&gt;r: l,r=i,i+z[i]-1 return z 1-Base12345678910111213def extend_kmp_0_base(self,s): l,r=0,-1 n=len(s) z=[0]*n for i in range(1,n): if i&lt;=r: k=i-l+1 z[i]=min(z[k],r-i+1) while i+z[i]&lt;n and s[i+z[i]]==s[0+z[i]]: z[i]+=1 if i+z[i]-1&gt;r: l,r=i,i+z[i]-1 return z 完整代码 | 哈希字符串 + Kmp哈希字符串123456789101112131415161718192021222324252627282930313233343536373839404142class Kmp(): def __init__(self,strs,target) -&gt; None: self.s=strs self.t=target self.m=len(self.s) self.n=len(self.t) self.pp=131 self.pre=[0]*self.m self.pattern_val=-1 self.ans=-1 # 求取匹配串的哈希数值 def get_v(self): for k,v in enumerate(self.t): cur=ord(v)-ord(&#x27;a&#x27;)+1 if k: self.pattern_val=self.pattern_val*self.pp+cur else: self.pattern_val=cur # 利用前缀哈希和 求取 def get_ans(self): for k,v in enumerate(self.s): cur=ord(v)-ord(&#x27;a&#x27;)+1 if k: self.pre[k]=self.pre[k-1]*self.pp+cur else: self.pre[k]=cur if k==self.n-1: if self.pre[k]==self.pattern_val: self.ans=0 break if k&gt;self.n-1: val=self.pre[k]-self.pre[k-self.n]*pow(self.pp,self.n) if self.pattern_val==val: self.ans=k+1-self.n break def run(self): self.get_v() return self.get_ans() Kmp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class Kmp(): def __init__(self,strs,target) -&gt; None: self.s=strs self.t=target self.m=len(self.s) self.n=len(self.t) self.nxt=[0]*(self.n+1) self.nxtval=[0]*(self.n+1) def plain_match(self): ans=-1 for i in range(self.m-self.n+1): k=i flag=1 for j in range(self.n): if self.s[k]!=self.t[j]: flag=0 break else: k+=1 if flag: ans=i break return ans def get_next(self): j=0 for i in range(1,self.n): while j and self.t[i]!=self.t[j]: j=self.nxt[j] if self.t[i]==self.t[j]: j+=1 self.nxt[i+1]=j def get_nextval(self): j=0 for i in range(1,self.n): while j and self.t[i]!=self.t[j]: j=self.nxtval[j] if self.t[i]==self.t[j]: j+=1 self.nxtval[i+1]=j # 纯直接丑陋思路 | 没想到更好的 不过这样也不错! if self.t[self.nxtval[i]]==self.t[i]: self.nxtval[i]=self.nxtval[self.nxtval[i]] def get_key(self,nxt): ans=-1 j=0 for i in range(self.m): while j and self.s[i]!=self.t[j]: j=nxt[j] if self.s[i]==self.t[j]: j+=1 if j==self.n: ans=i+1-self.n break return ans def get_key_count(self,nxt): ans=j=0 for i in range(self.m): while j and self.s[i]!=self.t[j]: j=nxt[j] if self.s[i]==self.t[j]: j+=1 if j==self.n: j=nxt[j] ans+=1 return ans def get_key_bool(self,nxt): return self.get_key(nxt)!=-1 # 拓展kmp算法! | def extend_kmp_1_base(self,s): l,r=1,0 s=&#x27;0&#x27;+s n=len(s) z=[0]*(n) for i in range(2,n): if i&gt;r: z[i]=0 else: k=i-l+1 z[i]=min(z[k],r-i+1) while i+z[i]&lt;n and s[i+z[i]]==s[1+z[i]]: z[i]+=1 if i+z[i]-1&gt;r: l,r=i,i+z[i]-1 return z def extend_kmp_0_base(self,s): l,r=0,-1 n=len(s) z=[0]*n for i in range(1,n): if i&lt;=r: k=i-l+1 z[i]=min(z[k],r-i+1) while i+z[i]&lt;n and s[i+z[i]]==s[0+z[i]]: z[i]+=1 if i+z[i]-1&gt;r: l,r=i,i+z[i]-1 return z","categories":["算法学习","字符串","Kmp"]},{"path":"/2023/01/16/整数除法/","content":"整数除法 | 笔记整理! 小知识点 | 总结快速幂思路优化 加法优化 12345678def quick_mul(x,y): ans=0 while y: if y&amp;1: ans+=x x+=x y&gt;&gt;=1 return ans 幂乘优化 12345678def quick_pow(x,y): ans=0 while y: if y&amp;1: ans+=x x&lt;&lt;=1 y&gt;&gt;=1 return ans 整数二分 | 向下取整 -&gt; 左闭右开区间思路 寻找后继 | 向上取整 12345678910def binary_search_right(nums,n,val): # 左闭右开区间 l,r=0,n while l&lt;r: mid=l+r&gt;&gt;1 if nums[mid]&gt;=val: r=mid else: l=mid+1 return l 寻找前驱 | 向下取整 12345678910def binary_search_left(nums,n,val): # 左闭右开区间 l,r=0,n while l&lt;r: mid=(l+r+1)&gt;&gt;1 if nums[mid]&lt;=val: l=mid else: r=mid-1 return l 特判 + 符号 | 二分 + 加法123456789101112131415161718192021222324252627282930313233class Solution: def divide(self, a: int, b: int) -&gt; int: # 快速幂优化 def quick_mul(x,y): ans=0 while y: if y&amp;1: ans+=x x+=x y&gt;&gt;=1 return ans # 先进行特判 INT_MIN,INT_MAX=-2**31,2**31-1 if a==INT_MIN: if b==1:return a if b==-1:return INT_MAX # 二分实现 经典的左闭右开区间 tag=1 if a*b&gt;=0 else -1 if a&lt;0:a=-a if b&lt;0:b=-b def binary_search_left(l,r): while l&lt;r: mid=l+r+1&gt;&gt;1 if quick_mul(mid,b)&lt;=a: l=mid else: r=mid-1 return l ans=binary_search_left(0,a) return ans*tag 模拟实现 | 但不符合题目要求123456789101112131415161718192021class Solution: def divide(self,a: int, b: int) -&gt; int: INT_MIN,INT_MAX=-2**31,2**31-1 if a==INT_MIN: if b==1:return a if b==-1:return INT_MAX t=1 if a*b&gt;=0 else -1 m,n=str(abs(a)),str(abs(b)) flag=[&#x27;0&#x27;]*len(m) def helper(x,y): r=0 for i in range(len(m)): r=r*10+ord(x[i])-ord(&#x27;0&#x27;) if r&lt;y: flag[i]=&#x27;0&#x27; else: flag[i]=str(r//y) r%=y helper(m,abs(b)) return t*int(&#x27;&#x27;.join(flag))","categories":["算法学习","整数除法"]},{"path":"/2023/01/16/回文串判断/","content":"回文串 | 笔记整理! 回文串判断暴力 | 中心扩散法1234567891011121314151617class Solution: def longestPalindrome(self, s: str) -&gt; str: n=len(s) def helper(i,j): while i&gt;=0 and j&lt;n and s[i]==s[j]: i-=1 j+=1 return i+1,j-1 #回复到原本状态 st,e=0,0 for i in range(0,n): a,b=helper(i,i) if b-a&gt;e-st: st,e=a,b c,d=helper(i,i+1) if d-c&gt;e-st: st,e=c,d return s[st:e+1] 优化 | 动态规划思路 参考《算法笔记》思路 123456789101112131415161718192021222324class Solution: def longestPalindrome(self, s: str) -&gt; str: n=len(s) dp=[[0 for _ in range(n)] for _ in range(n)] ans=1 idx=0 for i in range(n): dp[i][i]=1 #本身就是回文串 if i+1&lt;n and s[i]==s[i+1]: dp[i][i+1]=1 #两个最基本的连续 if ans&lt;2: ans=2 idx=i for k in range(3,n+1):# 从3~n进行遍历 如果这个字符串整个都是 回文串的话 for i in range(n): j=k+i-1 if j&gt;=n:break if s[i]==s[j] and dp[i+1][j-1]==1: dp[i][j]=1 if ans&lt;k: ans=k idx=i return s[idx:idx+ans] 优化 | $manacher$算法 比较有难度,参考罗勇军老师的《算法竞赛》一书 12345678910111213141516171819202122232425class Solution: def longestPalindrome(self, s: str) -&gt; str: # manacher马拉车 ls=&#x27;#&#x27;+&#x27;#&#x27;.join(list(s))+&#x27;#&#x27; n=len(ls) p=[1]*n #改进一下 --&gt;初始化为1 即可 r,c=0,0 ans,idx=0,0 for i in range(1,n): if i&lt;r: p[i]=min(p[2*c-i],c+p[c]-i) # 暴力中心扩散 while i+p[i]&lt;n and i-p[i]&gt;=0 and ls[i+p[i]]==ls[i-p[i]]:p[i]+=1 # 更新回文中心即可 if i+p[i]&gt;r: r=i+p[i] c=i # 用作数据统计分析 if p[i]&gt;ans: ans,idx=p[i],i ans-=1 st=(idx-ans)//2 return s[st:st+ans]","categories":["算法学习","回文串"]},{"path":"/2023/01/16/前缀树/","content":"字典树 | 笔记整理! 字典树实现 | 数组 + 字典(哈希表)208.实现 Trie (前缀树) 数组存储1234567891011121314151617181920212223242526272829class Trie(): def __init__(self) -&gt; None: self.d=[0]*26 self.flag=False def insert(self,words): node=self for i in words: i=ord(i)-ord(&#x27;a&#x27;) if node.d[i]==0: node.d[i]=Trie() node=node.d[i] node.flag=True def search(self,words): node=self.search_prefix(words) return node!=None and node.flag def search_prefix(self,words): node=self for i in words: i=ord(i)-ord(&#x27;a&#x27;) if node.d[i]==0: return None node=node.d[i] return node def startsWith(self,words): return self.search_prefix(words)!=None 哈希表(字典)存储1234567891011121314151617181920212223242526272829class Trie: def __init__(self): self.d=defaultdict(int) self.tag=False def insert(self, word: str) -&gt; None: node=self for i in word: v=ord(i)-ord(&#x27;a&#x27;) if not node.d[v]: node.d[v]=Trie() node=node.d[v] node.tag=True def search_prefix(self, word: str) -&gt; bool: node=self for i in word: v=ord(i)-ord(&#x27;a&#x27;) if not node.d[v]: return None node=node.d[v] return node def search(self,word): node=self.search_prefix(word) return node is not None and node.tag def startsWith(self, prefix: str) -&gt; bool: return self.search_prefix(prefix) is not None 应用判断前缀和14. 最长公共前缀 暴力 | 强行操作即可123456789101112class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: def helper(x,y): i=0 while i&lt;len(x) and i&lt;len(y) and x[i]==y[i]: i+=1 return x[:i] n=len(strs) ans=strs[0] for i in range(1,n): ans=helper(ans,strs[i]) return ans 分治 | 参考归并排序 (合并k个链表)12345678910111213141516class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: ### 分治思想 def helper(l,r): if l&gt;=r: return strs[l] mid=l+r&gt;&gt;1 l=helper(l,mid) r=helper(mid+1,r) k=min(len(l),len(r)) for i in range(k): if l[i]!=r[i]: k=i break return l[:k] return helper(0,len(strs)-1) 前缀树 | 存储 字符即可123456789101112131415161718192021222324252627class Trie: def __init__(self): self.d=defaultdict(int) self.tag=False def insert(self, word: str) -&gt; None: node=self for v in word: if not node.d[v]: node.d[v]=Trie() node=node.d[v] node.tag=True def search(self, word: str) -&gt; bool: node=self ans=&#x27;&#x27; for v in word: ### 遇到分治或是到达低端 就判断即可! if len(node.d)&gt;1 or node.tag: return ans if v in node.d: ans+=v node=node.d[v] return ansclass Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: t=Trie() for i in strs:t.insert(i) return t.search(strs[0])","categories":["算法学习","树","字符串"]},{"path":"/2023/01/13/有趣的题/","content":"好题 | 笔记整理! 链表+ 树(层次遍历) | bfs +dfs | 心得面试题 04.03. 特定深度节点链表 bfs | 借助队列处理 常规处理 1234567891011121314151617class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: q=[tree] ans=[] while q: sz=len(q) pre=x=ListNode() for i in range(sz): node=q[0] del q[0] x.next=ListNode(node.val) x=x.next if node.left:q.append(node.left) if node.right:q.append(node.right) x.next=None ans.append(pre.next) return ans dfs | 先left | 先right 受树层次遍历启发! 先left处理 | 插入节点是在末位 并不是很常见 12345678910111213141516171819# 先left处理时候 插入节点是在链表末位插入class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append(ListNode(root.val)) else: pre=ans[level] # 末位处理|找到链表结尾部分 while pre.next:pre=pre.next pre.next=cur pre=pre.next dfs(root.left,level+1) dfs(root.right,level+1) dfs(tree,0) return ans 可以存储末位部分 略有优化 123456789101112131415class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append([cur,cur]) else: ans[level][-1].next=cur ans[level][-1]=ans[level][-1].next dfs(root.left,level+1) dfs(root.right,level+1) dfs(tree,0) return [k for k,_ in ans] 先right处理 | 直接尾插法即可2326. 螺旋矩阵 IV 比较容易 123456789101112131415class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append(cur) else: cur.next=ans[level] ans[level]=cur dfs(root.right,level+1) dfs(root.left,level+1) dfs(tree,0) return ans 螺旋数组 | 笔记心得暴力破解 | 只能暴力找规律 过于漫长! 123456789101112131415161718192021222324252627282930313233class Solution: def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -&gt; List[List[int]]: ls=[[-1 for _ in range(n)] for _ in range(m)] l,r=0,n-1 t,d=0,m-1 while head: # 向左移动 i,j=t,l while j&lt;=r and head: ls[i][j]=head.val head=head.next j+=1 t+=1 i,j=t,r # 向下走 while i&lt;=d and head: ls[i][j]=head.val head=head.next i+=1 r-=1 i,j=d,r while j&gt;=l and head: ls[i][j]=head.val head=head.next j-=1 d-=1 i,j=d,l while i&gt;=t and head: ls[i][j]=head.val head=head.next i-=1 l+=1 return ls 逻辑优化一下 | 试试看 借鉴大佬 | 确实6 1234567891011121314151617class Solution: def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -&gt; List[List[int]]: ans=[[-1]*n for _ in range(m)] # 模拟右下左上 d=[[0,1],[1,0],[0,-1],[-1,0]] idx=0 cur=[0,0] while head: l,r=cur ans[l][r]=head.val i,j=d[idx] if not 0&lt;=l+i&lt;m or not 0&lt;=r+j&lt;n or ans[l+i][r+j]!=-1: idx=(idx+1)%4 i,j=d[idx] cur=[l+i,r+j] head=head.next return ans","categories":["算法学习","有趣的题"]},{"path":"/2023/01/13/链表/","content":"链表 | 笔记整理! 算法竞赛 | 例题:约瑟夫 算法竞赛例题 | 洛谷 P1996 约瑟夫问题 题目# P1996 约瑟夫问题 求解数组 | 标记 模拟12345678910111213m,n=map(int,input().split())flag=[0]*(m+1)idx=0for i in range(m):\tj=0\twhile j&lt;n: idx+=1 if idx&gt;m:idx=1 if flag[idx]:j-=1 j+=1\tprint(idx,end=&#x27; &#x27;)\tflag[idx]=1 单链表处理1234567891011121314151617181920212223m,n=map(int,input().split())class LinkNode():\tdef __init__(self,val=0,next=None) -&gt; None: self.val=val self.next=nextnode=cur=Nonefor i in range(1,m+1):\tif i==1: cur=node=LinkNode(i)\telse: cur.next=LinkNode(i) cur=cur.nextcur.next=nodehead=prev=nodefor _ in range(m):\tfor _ in range(1,n): prev=head head=head.next\tprint(head.val,end=&#x27; &#x27;)\tprev.next=head.next\thead=prev.next 静态链表处理123456789101112131415m,n=map(int,input().split())node=[0]*(m+1)for i in range(1,m):\tnode[i]=i+1node[m]=1prev=head=1for _ in range(m):\tfor _ in range(1,n): prev=head head=node[head]\tprint(head,end=&#x27; &#x27;)\tnode[prev]=node[head]\thead=node[prev] 力扣刷题 | 部分经典题目 部分总结归纳 dfs做法 | 笔记整理在另一篇面试题 04.03. 特定深度节点链表 123456789101112131415class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append(cur) else: cur.next=ans[level] ans[level]=cur dfs(root.right,level+1) dfs(root.left,level+1) dfs(tree,0) return ans 模拟加减运算链表求和 12345678910111213141516171819class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: def cal_ans(l1,l2): flag=0 head=ans=ListNode() while l1 or l2: x=l1.val if l1 else 0 y=l2.val if l2 else 0 s=x+y+flag flag=s//10 cur=ListNode(s%10) ans.next=cur ans=ans.next if l1:l1=l1.next if l2:l2=l2.next if flag: ans.next=ListNode(1) return head.next return cal_ans(l1,l2) 环路检测 问题 set集合检测 | 环装归纳 环路检测 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def detectCycle(self, head: ListNode) -&gt; ListNode: # 经典做法就是 用set来存储 然后进行检测 # 优化方案--&gt;快慢指针(叫双指针也行) # b是环的起点到相遇的地方(c的开始)--&gt;故相遇之后a==c # 原理推导 a+n(b+c)+b==2(a+b)--&gt;a=(n-1)b+cn #--&gt;a=c+(n-1)(b+c) (b+c是环) fast=slow=head while fast: slow=slow.next if fast.next: fast=fast.next.next else: return None if fast==slow: while head!=slow: head=head.next slow=slow.next return head return None 链表 + 前缀和从链表中删去总和值为零的连续节点 12345678910111213141516171819# 使用dict来存储,第一次遍历会覆盖重复的pre保留为最后一次的class Solution: def removeZeroSumSublists(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: cur=dummpy=ListNode(0,head) pre=0 d=dict() while cur: pre+=cur.val d[pre]=cur cur=cur.next s=0 cur=dummpy while cur: s+=cur.val cur.next=d[s].next cur=cur.next return dummpy.next 经典递归调用 | 树+链表 此处过于精彩! 二叉树中的链表 1234567891011class Solution: def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -&gt; bool: def helper(head,root): if not head:return True if not root:return False if head.val!=root.val: return False return helper(head.next,root.left) or helper(head.next,root.right) # 突破口是 在这里 不断的递归枚举调用! if not root:return False return helper(head,root) or self.isSubPath(head,root.left) or self.isSubPath(head,root.right) 小结 这部分还是比较重要的，如果单纯考链表就比较容易了！","categories":["算法学习","数据结构","链表"]},{"path":"/2023/01/12/堆/","content":"堆| 笔记整理! 思路梳理 | 结构体部分123def __init__(self) -&gt; None: self.heap_list=[0] self.length=0 主体部分是 | 上升和下降上升部分 | 对应的是 插入1234567891011def perc_up(self,i): while i//2&gt;0: # 当前节点是 小于父节点的 if self.heap_list[i]&lt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1def insert(self,k): self.heap_list.append(k) self.length+=1 self.perc_up(self.length) 下降部分 | 对应的是建立 + 删除堆顶元素123456789101112131415161718192021222324252627282930def perc_down(self,i): while i*2&lt;=self.length: idx=self.min_child(i) if self.heap_list[i]&gt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx def min_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&lt;self.heap_list[i*2+1]: return i*2 return i*2+1 def del_min(self): min_val=self.heap_list[1] # self.heap_list[1]=self.heap_list[self.length] # 这样来写也可以id self.heap_list[-1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return min_val def build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1 完整代码 | 关于最大堆+最小堆最大堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class BinaryHeap():\tdef __init__(self): self.heap_list=[0] self.length=0\tdef insert(self,i): self.heap_list.append(i) self.length+=1 self.perc_up(self.length)\tdef perc_up(self,i): while i//2&gt;0: if self.heap_list[i]&gt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1\tdef max_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&gt;self.heap_list[i*2+1]: return i*2 return i*2+1\tdef del_max(self,i): val=self.heap_list[1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return val\tdef perc_down(self,i): while i*2&lt;=self.length: idx=self.max_child(i) if self.heap_list[i]&lt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx\tdef build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1if __name__==&#x27;__main__&#x27;:\tls=[9,5,6,3,2,3,10]\theap=BinaryHeap()\theap.build_heap(ls)\tprint(heap.heap_list) 最小堆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class BinaryHeap(): def __init__(self) -&gt; None: self.heap_list=[0] self.length=0 def perc_up(self,i): while i//2&gt;0: # 当前节点是 小于父节点的 if self.heap_list[i]&lt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1 def insert(self,k): self.heap_list.append(k) self.length+=1 self.perc_up(self.length) def perc_down(self,i): while i*2&lt;=self.length: idx=self.min_child(i) if self.heap_list[i]&gt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx def min_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&lt;self.heap_list[i*2+1]: return i*2 return i*2+1 def del_min(self): min_val=self.heap_list[1] # self.heap_list[1]=self.heap_list[self.length] # 这样来写也可以id self.heap_list[-1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return min_val def build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1if __name__==&#x27;__main__&#x27;: ls=[9,6,5,2,3] heap=BinaryHeap() heap.build_heap(ls) print(heap.heap_list)","categories":["算法学习","树","堆"]},{"path":"/2023/01/12/排序/","content":"排序 | 笔记整理! 快速排序123456789101112131415161718192021222324252627282930import numpy as npdef quick_sort(nums,l,r): if l&gt;=r: return # 稍微进行优化! rand=l+np.random.randint(100)%(r-l+1) nums[l],nums[rand]=nums[rand],nums[l] x=nums[l] i,j=l,r while i&lt;j: while i&lt;j and nums[j]&gt;x:j-=1 if i&lt;j: nums[i]=nums[j] i+=1 while i&lt;j and nums[i]&lt;x:i+=1 if i&lt;j: nums[j]=nums[i] j-=1 nums[i]=x quick_sort(nums,l,i-1) quick_sort(nums,i+1,r)if __name__==&#x27;__main__&#x27;: nums=np.random.randint(100,size=12) print(&quot;生成的数组是:&quot;,nums) quick_sort(nums,0,11) print(&quot;排序后数组是:&quot;,nums) 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npdef merge_sort(nums,l,r): if l&gt;=r: return mid=l+r&gt;&gt;1 # 对于 l~mid 和 mid+1~r 进行分别处理 merge_sort(nums,l,mid) merge_sort(nums,mid+1,r) # 此处已经是 处理之后的 结果.进行归并即可! i,j=l,mid+1 idx=0 while i&lt;=mid and j&lt;=r: if nums[i]&lt;=nums[j]: help_ls[idx]=nums[i] i+=1 else: help_ls[idx]=nums[j] j+=1 idx+=1 while i&lt;=mid: help_ls[idx]=nums[i] i+=1 idx+=1 while j&lt;=r: help_ls[idx]=nums[j] j+=1 idx+=1 # 进行复制即可 for i in range(idx): nums[l+i]=help_ls[i]if __name__==&#x27;__main__&#x27;: n=12 nums=np.random.randint(100,size=n) help_ls=[0]*n # 生成辅助数组 print(&quot;生成的数组是:&quot;,nums) merge_sort(nums,0,11) print(&quot;排序后数组是:&quot;,nums) 计数排序 理解记忆 1234567891011121314151617181920212223242526272829303132import numpy as npdef counting_sort(nums): # 进行计数 for i in nums: help_c[i]+=1 # 输出结果 print(&quot;排序后数组是:&quot;,end=&#x27; &#x27;) for i in range(max_val): for j in range(help_c[i]): #需要重复的次数是 print(i,end=&#x27; &#x27;) # 前缀和 for i in range(1,max_val): help_c[i]+=help_c[i-1] for i in range(n-1,-1,-1): help_r[i]=help_c[nums[i]] help_c[nums[i]]-=1 print(&quot; 出现的次序:&quot;,end=&#x27; &#x27;) for i in range(n): print(help_r[i],end=&#x27; &#x27;)if __name__==&#x27;__main__&#x27;: n=12 max_val=10 nums=np.random.randint(max_val,size=n) help_a=[0]*n # 生成辅助数组 help_c=[0]*n # 生成辅助数组 help_r=[0]*n # 生成辅助数组 print(&quot;生成的数组是:&quot;,nums) counting_sort(nums) 基数排序1234567891011121314151617181920212223242526272829303132import numpy as npdef counting_sort(): help_c=[0]*10 # 生成辅助数组 # 进行计数即可 for i in help_v: help_c[i]+=1 # 前缀和 for i in range(1,10): help_c[i]+=help_c[i-1] # 从后开始 这是用help_s用来标记位次顺序 for i in range(n-1,-1,-1): help_r[help_s[i]]=help_c[help_v[help_s[i]]] help_c[help_v[help_s[i]]]-=1 # 记录这次之后的位次顺序 因为是从0开始的 位次是1 for i in range(n): help_s[help_r[i]-1]=iif __name__==&#x27;__main__&#x27;: n=12 max_val=100 nums=np.random.randint(max_val,size=n) help_s=list(range(n)) help_r=[0]*n # 生成辅助数组 help_v=[0]*n # 生成辅助数 x=1 print(&quot;生成的数组是:&quot;,list(nums)) for i in range(2): for j in range(n): help_v[j]=nums[j]//x%10 counting_sort() x*=10 print(&quot;排序后数组是:&quot;,[nums[help_s[i]] for i in range(n)])","categories":["算法学习","排序"]},{"path":"/2023/01/12/字符串/","content":"字符串转换数字 | 笔记整理! 字符串字符串转为数字[]12345678910111213141516# 使用for循环即可! 需要考虑末位class Solution: def areNumbersAscending(self, s: str) -&gt; bool: pre=0 num=0 for i in s: if &#x27;0&#x27;&lt;=i&lt;=&#x27;9&#x27;: num=num*10+ord(i)-ord(&#x27;0&#x27;) else: if num&gt;=1: if pre&gt;=num:return False pre=num num=0 # 需要考虑到末位 if num and pre&gt;=num:return False return True []1234567891011121314151617181920# 使用while遍历即可class Solution: def areNumbersAscending(self, s: str) -&gt; bool: pre=0 n=len(s) i=0 num=0 while i&lt;n: if s[i].isdigit(): while i&lt;n and s[i].isdigit(): num=num*10+ord(s[i])-ord(&#x27;0&#x27;) i+=1 if not pre: pre=num elif pre&gt;=num:return False else:pre=num print(num) num=0 i+=1 return True","categories":["算法学习","字符串"]},{"path":"/2023/01/12/解析树/","content":"解析树| 笔记整理! 笔记心得 参考Python数据结构(外) 结构体部分 | 插入部分是必要的1234567891011121314151617181920class TreeNode: def __init__(self, val=&#x27;&#x27;, left=None, right=None): self.val = val self.left = left self.right = right def insert_left(self,val=&#x27;&#x27;): t=TreeNode(val) if not self.left: self.left=t else: t.left=self.left self.left=t def insert_right(self,val=&#x27;&#x27;): t=TreeNode(val) if not self.right: self.right=t else: t.right=self.right self.right=t 进行建树 | 合理利用栈即可1234567891011121314151617181920212223def build_parse_tree(s): ls=list(s) root=TreeNode() stk=[root] cur=root for i in ls: if i==&#x27;(&#x27;: cur.insert_left() #进行占位 stk.append(cur) cur=cur.left elif i not in &#x27;+-*/)&#x27;: cur.val=int(i) cur=stk.pop() elif i in &#x27;+-*/&#x27;: cur.val=i cur.insert_right() stk.append(cur) cur=cur.right elif i==&#x27;)&#x27;: cur=stk.pop() else: raise ValueError(&quot;当前输入不合法!&quot;) return root 计算解析树 | 递归处理12345678910111213def get_ans(root): map=&#123; &#x27;+&#x27;:lambda x,y:x+y, &#x27;-&#x27;:lambda x,y:x-y, &#x27;*&#x27;:lambda x,y:x*y, &#x27;/&#x27;:lambda x,y:x/y, &#125; l=root.left r=root.right if l and r: return map[root.val](get_ans(l),get_ans(r)) else: return root.val 遍历输出 | 利用中序遍历 这部分不自信 错了滴滴我 原书思路12345def print_exp1(root): ans=&#x27;&#x27; if root: ans=&#x27;(&#x27;+print_exp(root.left)+str(root.val)+print_exp(root.right)+&#x27;)&#x27; return ans 优化12345678def print_exp2(root): ans=&#x27;&#x27; if root: if root.left and root.right: ans=&#x27;(&#x27;+print_exp(root.left)+str(root.val)+print_exp(root.right)+&#x27;)&#x27; else: ans=print_exp(root.left)+str(root.val)+print_exp(root.right) return ans 感觉还可以优化一下 | 根据优先级12345678910111213141516def helper(root,flag): map=&#123; &#x27;+&#x27;:1,&#x27;-&#x27;:1, &#x27;*&#x27;:2,&#x27;/&#x27;:2 &#125; ans=&#x27;&#x27; if root: ans=helper(root.left,flag)+str(root.val)+helper(root.right,flag) if root.left and root.right: if root.val in map and map[root.val]&gt;=flag: flag=map[root.val] ans=helper(root.left,flag)+str(root.val)+helper(root.right,flag) else: ans=&#x27;(&#x27;+ans+&#x27;)&#x27; return ans 感觉不是很难 | 2023.1.12 算法之路 不断精进!","categories":["算法学习","树"]},{"title":"关于","path":"/about/index.html","content":"夏桑就读于克莱登大学，职业写Bug，擅长摸鱼。实验室下班钟点工，精通各种编程技能，如手撕HelloWorld。力扣周赛坐牢冠军，专业认证CV工程师。前面的话都是编的，但说真的，很抱歉，怪遗憾的挺想你的。O(∩_∩)O哈哈~"},{"path":"/notes/index.html","content":"笔记部分"},{"path":"/more/rss/index.html","content":""}]