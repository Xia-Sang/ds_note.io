[{"title":"串匹配 | 笔记整理!","path":"/2023/07/08/串匹配/","content":"串匹配 | 笔记整理! 串匹配暴力匹配概述字符串暴力匹配是一种简单直接的匹配算法，也称为朴素匹配算法。它通过逐个字符地在主串中与模式串进行比较来找到匹配位置。 对于主串和匹配串进行暴力匹配，主串匹配时候索引会进行回溯！ 字符串暴力匹配的时间复杂度为O(m*n)，其中m为主串的长度，n为模式串的长度。它是一种简单易懂的匹配算法，但对于较大规模的字符串匹配效率较低。 代码1234567891011121314151617181920func bruteForce(s,p string)int&#123;\tm,n:=len(s),len(p)\tif n&gt;m&#123; return -1\t&#125;\tfor i:=0;i&lt;m;i++&#123; k:=i for j:=0;j&lt;n;j++&#123; if k&lt;m&amp;&amp;s[k]==p[j]&#123; k++ &#125;else&#123; break &#125; &#125; if i+n==k&#123; return i &#125;\t&#125;\treturn -1&#125; KMP匹配概述KMP（Knuth-Morris-Pratt）算法是一种字符串匹配算法，用于在一个主串中查找一个模式串的出现位置。它的核心思想是利用已经匹配过的信息来避免不必要的字符比较，从而提高匹配效率。 KMP算法的关键在于构建一个部分匹配表（Partial Match Table），也称为next数组。部分匹配表记录了模式串中每个位置之前的子串的最长相同前缀和后缀的长度。 下面是KMP算法的基本步骤： 预处理模式串：根据模式串构建部分匹配表，即计算next数组。next[i]表示模式串中以第i个字符结尾的子串的最长相同前缀和后缀的长度。 在主串中进行匹配：从主串的第一个字符开始，与模式串的第一个字符进行比较，如果相等，则比较下一个字符；如果不相等，则根据next数组移动模式串的指针。 根据next数组移动模式串指针：如果当前字符不匹配，根据next数组找到模式串的一个新的起始位置，从该位置重新开始匹配。 匹配成功：当模式串的指针移动到模式串的末尾时，表示匹配成功，返回主串中匹配开始的位置。 KMP算法通过预处理模式串构建部分匹配表，使得在匹配过程中避免了不必要的回溯，大大提高了匹配的效率。其时间复杂度为O(m+n)，其中m为主串的长度，n为模式串的长度。 过程推导存在联系 字符串匹配时候，可以不需要进行主串回溯，移动匹配串即可 对于匹配串的移动是重点，观察字符串移动规律，不难得出前后缀关系 数理推导next数组的推导是基于模式串自身的前缀和后缀的比较，可以使用递推的方式进行计算。 假设模式串为 p，next[i] 表示模式串中以第 i 个字符结尾的子串的最长相同前缀和后缀的长度。 初始化 next[0] = 0，因为一个字符的字符串没有真前缀和真后缀。 假设已知 next[0], next[1], ..., next[i-1] 的值，考虑如何求解 next[i]。 当模式串的第 i 个字符与前一个字符匹配时，即 p[i] == p[next[i-1]]，可以扩展当前的相同前缀和后缀。 如果模式串的第 i 个字符与前一个字符不匹配，即 p[i] != p[next[i-1]]，则需要回退到更短的相同前缀和后缀的位置继续比较。 因此，我们可以通过递归地比较模式串的前缀和后缀，来确定 next[i] 的值。 如果 p[i] == p[next[i-1]]，则 next[i] = next[i-1] + 1。 如果 p[i] != p[next[i-1]]，则需要继续回退，即将 next[i-1] 的值作为新的位置进行比较，即 next[i] = next[next[i-1]]。 重复步骤 3 和 4，直到找到一个匹配或回退到模式串的起始位置。 根据上述推导，可以得到 next 数组的递推公式如下： 如果 p[i] == p[next[i-1]]，则 next[i] = next[i-1] + 1。 如果 p[i] != p[next[i-1]]，则 next[i] = next[next[i-1]]。 匹配优化：Nextval概述在KMP算法中，可以通过优化next数组来进一步提高匹配的效率。优化后的数组通常称为nextval数组。nextval数组的作用是在失配时跳过尽可能多的字符，减少不必要的比较。 下面是对nextval数组的优化过程： 构建next数组：首先，根据模式串构建next数组，该数组表示模式串中每个位置之前的子串的最长相同前缀和后缀的长度。 优化nextval数组：在next数组的基础上，根据模式串的前缀和后缀的关系，计算出nextval数组。 初始化nextval数组，使每个元素等于对应位置的next数组的值。 从右往左遍历nextval数组（从倒数第二个位置开始）： 如果当前位置的nextval值大于0，则将当前位置的值更新为前一个位置的nextval值。 如果当前位置的nextval值等于0，且当前位置的字符与前一个位置的字符相同，将当前位置的值更新为前一个位置的nextval值加1。 在匹配过程中使用nextval数组：在主串与模式串进行匹配时，根据nextval数组的值进行指针的移动。 如果当前字符不匹配，根据nextval数组找到模式串的一个新的起始位置，从该位置重新开始匹配。 如果nextval数组中的值大于0，表示在失配时可以跳过尽可能多的字符，减少比较次数。 优化后的nextval数组使得在匹配过程中能够更有效地跳过不必要的字符比较，从而提高匹配的效率。 数理推导nextval 数组是 KMP 算法中的一个优化，用于在失配时进行跳跃。假设模式串为 p，nextval[i] 表示当模式串第 i 个字符失配时，应该跳跃到的位置。 初始化 nextval[0] = 0，表示模式串的第一个字符失配时跳跃到主串的下一个位置。 假设已知 nextval[0], nextval[1], ..., nextval[i-1] 的值，考虑如何求解 nextval[i]。 当模式串的第 i 个字符失配时，需要找到一个合适的跳跃位置。 如果 p[i] == p[nextval[i-1]]，即当前失配的字符与前一个字符匹配，可以继续比较下一个字符，因此 nextval[i] = nextval[i-1] + 1。 如果 p[i] != p[nextval[i-1]]，则需要回退到更短的相同前缀和后缀的位置继续比较。 因此，我们可以通过递归地比较模式串的前缀和后缀，来确定 nextval[i] 的值。 如果 p[i] == p[nextval[i-1]]，则 nextval[i] = nextval[i-1] + 1。 如果 p[i] != p[nextval[i-1]]，则需要继续回退，即将 nextval[nextval[i-1]] 的值作为新的位置进行比较，即 nextval[i] = nextval[nextval[i-1]]。 重复步骤 4 和 5，直到找到一个匹配或回退到模式串的起始位置。 代码风格索引从0开始123456789101112131415func getNext(t string) []int &#123;\tn := len(t)\tnxt := make([]int,n)\tnxt[0]=-1\tfor i,j := 0, -1; i &lt; n-1; &#123; if j == -1 || t[i] == t[j] &#123; i++ j++ nxt[i] = j &#125; else &#123; j = nxt[j] &#125;\t&#125;\treturn nxt&#125; 12345678910111213141516171819func getNextval(t string)[]int&#123;\tn := len(t)\tnxt := make([]int, n)\tnxt[0]=-1\tfor j, i := -1, 0; i&lt; n-1; &#123; if j == -1 || t[i] == t[j] &#123; i++ j++ if t[i]==t[j]&#123; nxt[i]=nxt[j] &#125;else&#123; nxt[i] = j &#125; &#125; else &#123; j = nxt[j] &#125;\t&#125;\treturn nxt&#125; 1234567891011121314151617181920func Kmp(s, t string) int &#123;\tm, n := len(s), len(t)\tif n &lt;= 0 &#123; return 0\t&#125;\tnxt := getNextval(t)\ti, j := 0, 0\tfor i &lt; m &amp;&amp; j &lt; n &#123; if j == -1 || s[i] == t[j] &#123; i++ j++ &#125; else &#123; j = nxt[j] &#125; if j == n &#123; return i - n &#125;\t&#125;\treturn -1&#125; 索引从1开始1234567891011121314func getNext(p string) []int &#123;\tn := len(p)\tnxt := make([]int, n)\tfor i, j := 1, 0; i &lt; n-1; &#123; if p[i] == p[j] || j == 0 &#123; i++ j++ nxt[i] = j &#125; else &#123; j = nxt[j] &#125;\t&#125;\treturn nxt&#125; 123456789101112131415161718func getNextval(p string) []int &#123;\tn := len(p)\tnxt := make([]int, n)\tfor i, j := 1, 0; i &lt; n-1; &#123; if p[i] == p[j] || j == 0 &#123; i++ j++ if p[i] == p[j] &#123; nxt[i] = nxt[j] &#125; else &#123; nxt[i] = j &#125; &#125; else &#123; j = nxt[j] &#125;\t&#125;\treturn nxt&#125; 12345678910111213141516171819202122func Kmp(s, p string) int &#123;\ts = &quot; &quot; + s\tp = &quot; &quot; + p\tm, n := len(s), len(p)\tif n &lt;= 0 &#123; return 0\t&#125;\tnxt := getNext(p)\ti, j := 0, 1\tfor i &lt; m &amp;&amp; j &lt; n &#123; if j == 0 || s[i] == p[j] &#123; i++ j++ &#125; else &#123; j = nxt[j] &#125; if j == n &#123; return i - n &#125;\t&#125;\treturn -1&#125; 补充：字符串哈希概述字符串哈希（String Hashing）是一种将字符串映射为哈希值的技术。它可以将任意长度的字符串转换为固定长度的哈希码，方便在算法和数据结构中进行字符串的比较和查找操作。 字符串哈希的基本思想是将字符串看作是一个数字序列，通过对字符串中的字符进行一系列的运算和组合，得到一个哈希值。常用的字符串哈希算法包括简单的多项式哈希、Rabin-Karp哈希和Rolling哈希等。 以下是一种简单的多项式哈希算法的描述： 选择一个合适的进制数（通常是一个素数），作为基数。例如，取素数31作为基数。 将字符串中的每个字符转换为对应的数值，可以使用字符的ASCII码值。 遍历字符串，对每个字符进行如下操作： 将前一个字符的哈希值乘以基数，再加上当前字符的数值。 这个步骤可以用以下公式表示：hash = hash * base + charValue。 重复步骤3，直到遍历完整个字符串。 最终得到的哈希值即为字符串的哈希码。 需要注意的是，字符串哈希可能存在哈希冲突，即不同的字符串可能得到相同的哈希值。为了尽量减少冲突的发生，通常会选择一个合适的基数和哈希算法。 字符串哈希在字符串匹配、查找和去重等场景中有广泛的应用。通过将字符串转换为哈希码，可以加速字符串的比较和查找操作，提高算法效率。","categories":["考研","数据结构"]},{"title":"并查集 | 笔记整理!","path":"/2023/07/08/并查集/","content":"并查集 | 笔记整理! 并查集结构体1234type UnionFind struct &#123;\tparent []int\trank []int&#125; 常规操作NewUnionFind 函数用于创建一个新的并查集实例。 1234567891011121314func NewUnionFind(size int) *UnionFind &#123;\tparent := make([]int, size)\trank := make([]int, size)\t// 初始化\tfor i := 0; i &lt; size; i++ &#123; parent[i] = i rank[i] = 0\t&#125;\treturn &amp;UnionFind&#123; parent: parent, rank: rank,\t&#125;&#125; 路径压缩该函数的作用是查找元素 x 所属的集合的根节点，并在查找过程中进行路径压缩，将元素 x 到根节点路径上的所有节点直接连接到根节点，以提高后续查找的效率。 123456func (uf *UnionFind) Find(x int) int &#123;\tif uf.parent[x] != x &#123; uf.parent[x] = uf.Find(uf.parent[x])\t&#125;\treturn uf.parent[x]&#125; 按秩合并并查集中的按秩合并优化策略，它基于每个集合的秩（rank）来决定合并时哪个集合的根节点指向哪个集合的根节点。 首先，秩是一个表示集合高度（或者近似高度）的指标。初始时，每个元素的秩都为 0。 在合并两个集合时，通过比较它们的秩，可以决定将一个集合的根节点指向另一个集合的根节点。具体的逻辑如下： 如果 uf.rank[rootX] &lt; uf.rank[rootY]，表示集合 Y 的秩更大，即集合 Y 的高度更大。在这种情况下，将集合 X 的根节点的父节点指向集合 Y 的根节点，因为将树高度较小的集合合并到树高度较大的集合中，不会增加整体树的高度。 如果 uf.rank[rootX] &gt; uf.rank[rootY]，表示集合 X 的秩更大，同理，将集合 Y 的根节点的父节点指向集合 X 的根节点。 如果 uf.rank[rootX] == uf.rank[rootY]，表示集合 X 和集合 Y 的秩相同，此时可以选择将集合 X 的根节点指向集合 Y 的根节点，也可以选择将集合 Y 的根节点指向集合 X 的根节点。在这里，我们选择将集合 Y 的根节点指向集合 X 的根节点，并且将集合 X 的秩加一，因为合并后，整个树的高度会增加一层。 这种按秩合并的优化策略可以有效地减小树的高度，提高并查集操作的效率，避免退化成链表式的数据结构。 123456789101112131415func (uf *UnionFind) Union(x, y int) &#123;\tpx, py := uf.Find(x), uf.Find(y)\tif px == py &#123; return\t&#125;\trx, ry := uf.rank[px], uf.rank[py]\tif rx &lt; ry &#123; uf.rank[rx] = ry\t&#125; else if rx &gt; ry &#123; uf.rank[ry] = rx\t&#125; else &#123; uf.rank[rx] = ry uf.rank[rx]++\t&#125;&#125; 辅助操作IsConnected 函数用于判断两个元素 x 和 y 是否属于同一个集合。 123func (uf *UnionFind) IsConnected(x, y int) bool &#123;\treturn uf.Find(x) == uf.Find(y)&#125; Getsets 方法，可以获取并查集中的所有集合以及它们的元素列表 12345678func (uf *UnionFind) Getsets() map[int][]int &#123;\tsets := make(map[int][]int)\tfor i := 0; i &lt; len(uf.parent); i++ &#123; root := uf.Find(i) sets[root] = append(sets[root], i)\t&#125;\treturn sets&#125;","categories":["考研","数据结构"]},{"title":"go web部分 | 笔记整理!","path":"/2023/07/08/go web部分/","content":"Go web部分 | 笔记整理! go web部分Server12345678// handler func(ResponseWriter, *Request))func handler(resp http.ResponseWriter, req *http.Request) &#123;\tfmt.Fprintf(resp, &quot;hello world! url: %s&quot;, req.URL.Path)&#125;func main() &#123;\thttp.HandleFunc(&quot;/&quot;, handler)\thttp.ListenAndServe(&quot;:8080&quot;, nil)&#125; 1. HandleFunc123456// HandleFunc registers the handler function for the given pattern// in the DefaultServeMux.// The documentation for ServeMux explains how patterns are matched.func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;\tDefaultServeMux.HandleFunc(pattern, handler)&#125; 12345678910111213141516171819type ServeMux struct &#123;\tmu sync.RWMutex\tm map[string]muxEntry\tes []muxEntry // slice of entries sorted from longest to shortest.\thosts bool // whether any patterns contain hostnames&#125;type muxEntry struct &#123;\th Handler\tpattern string&#125;// NewServeMux allocates and returns a new ServeMux.func NewServeMux() *ServeMux &#123; return new(ServeMux) &#125;// DefaultServeMux is the default ServeMux used by Serve.var DefaultServeMux = &amp;defaultServeMuxvar defaultServeMux ServeMux 1234567// HandleFunc registers the handler function for the given pattern.func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;\tif handler == nil &#123; panic(&quot;http: nil handler&quot;)\t&#125;\tmux.Handle(pattern, HandlerFunc(handler))&#125; 1234567891011121314151617181920212223242526272829// Handle registers the handler for the given pattern.// If a handler already exists for pattern, Handle panics.func (mux *ServeMux) Handle(pattern string, handler Handler) &#123;\tmux.mu.Lock()\tdefer mux.mu.Unlock()\tif pattern == &quot;&quot; &#123; panic(&quot;http: invalid pattern&quot;)\t&#125;\tif handler == nil &#123; panic(&quot;http: nil handler&quot;)\t&#125;\tif _, exist := mux.m[pattern]; exist &#123; panic(&quot;http: multiple registrations for &quot; + pattern)\t&#125;\tif mux.m == nil &#123; mux.m = make(map[string]muxEntry)\t&#125;\te := muxEntry&#123;h: handler, pattern: pattern&#125;\tmux.m[pattern] = e\tif pattern[len(pattern)-1] == &#x27;/&#x27; &#123; mux.es = appendSorted(mux.es, e)\t&#125;\tif pattern[0] != &#x27;/&#x27; &#123; mux.hosts = true\t&#125;&#125; 2. ListenAndServe123456789101112131415161718192021// ListenAndServe listens on the TCP network address addr and then calls// Serve with handler to handle requests on incoming connections.// Accepted connections are configured to enable TCP keep-alives.//// The handler is typically nil, in which case the DefaultServeMux is used.//// ListenAndServe always returns a non-nil error.func ListenAndServe(addr string, handler Handler) error &#123;\tserver := &amp;Server&#123;Addr: addr, Handler: handler&#125;\treturn server.ListenAndServe()&#125;// --.&gt;补充一下https部分// ListenAndServeTLS acts identically to ListenAndServe, except that it// expects HTTPS connections. Additionally, files containing a certificate and// matching private key for the server must be provided. If the certificate// is signed by a certificate authority, the certFile should be the concatenation// of the server&#x27;s certificate, any intermediates, and the CA&#x27;s certificate.func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error &#123;\tserver := &amp;Server&#123;Addr: addr, Handler: handler&#125;\treturn server.ListenAndServeTLS(certFile, keyFile)&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455type Server struct &#123; Addr string Handler Handler DisableGeneralOptionsHandler bool TLSConfig *tls.Config ReadTimeout time.Duration ReadHeaderTimeout time.Duration WriteTimeout time.Duration IdleTimeout time.Duration MaxHeaderBytes int TLSNextProto map[string]func(*Server, *tls.Conn, Handler) ConnState func(net.Conn, ConnState) ErrorLog *log.Logger BaseContext func(net.Listener) context.Context ConnContext func(ctx context.Context, c net.Conn) context.Context inShutdown atomic.Bool disableKeepAlives atomic.Bool nextProtoOnce sync.Once nextProtoErr error mu sync.Mutex listeners map[*net.Listener]struct&#123;&#125; activeConn map[*conn]struct&#123;&#125; onShutdown []func() listenerGroup sync.WaitGroup&#125;A Server defines parameters for running an HTTP server. The zero value for Server is a valid configuration. Methods on (*Server): newConn(rwc net.Conn) *conn maxHeaderBytes() int initialReadLimitSize() int64 tlsHandshakeTimeout() time.Duration Close() error Shutdown(ctx context.Context) error RegisterOnShutdown(f func()) closeIdleConns() bool closeListenersLocked() error ListenAndServe() error shouldConfigureHTTP2ForServe() bool Serve(l net.Listener) error ServeTLS(l net.Listener, certFile string, keyFile string) error trackListener(ln *net.Listener, add bool) bool trackConn(c *conn, add bool) idleTimeout() time.Duration readHeaderTimeout() time.Duration doKeepAlives() bool shuttingDown() bool SetKeepAlivesEnabled(v bool) logf(format string, args ...any) ListenAndServeTLS(certFile string, keyFile string) error setupHTTP2_ServeTLS() error setupHTTP2_Serve() error onceSetNextProtoDefaults_Serve() onceSetNextProtoDefaults() ExportAllConnsIdle() bool ExportAllConnsByState() map[ConnState]int 123type Handler interface &#123; ServeHTTP(ResponseWriter, *Request)&#125; 模拟实现一下1234567891011121314// handler func(ResponseWriter, *Request))type Myhander struct &#123;&#125;func (my *Myhander) ServeHTTP(resp http.ResponseWriter, req *http.Request) &#123;\tfmt.Fprintf(resp, &quot;hello world! url: %s&quot;, req.URL.Path)&#125;func main() &#123;\t//http.HandleFunc(&quot;/&quot;, handler)\t//http.ListenAndServe(&quot;:8080&quot;, nil)\tmyhander := Myhander&#123;&#125;\tserver := &amp;http.Server&#123;Addr: &quot;:8080&quot;, Handler: &amp;myhander&#125;\tserver.ListenAndServe()&#125; Dir1234567891011121314151617// A Dir implements FileSystem using the native file system restricted to a// specific directory tree.//// While the FileSystem.Open method takes &#x27;/&#x27;-separated paths, a Dir&#x27;s string// value is a filename on the native file system, not a URL, so it is separated// by filepath.Separator, which isn&#x27;t necessarily &#x27;/&#x27;.//// Note that Dir could expose sensitive files and directories. Dir will follow// symlinks pointing out of the directory tree, which can be especially dangerous// if serving from a directory in which users are able to create arbitrary symlinks.// Dir will also allow access to files and directories starting with a period,// which could expose sensitive directories like .git or sensitive files like// .htpasswd. To exclude files with a leading period, remove the files/directories// from the server or create a custom FileSystem implementation.//// An empty Dir is treated as &quot;.&quot;.type Dir string FileServer1234567891011121314151617181920212223242526package mainimport (\t&quot;fmt&quot;\t&quot;net/http&quot;)func main() &#123;\tmux := http.NewServeMux()\tfile := http.FileServer(http.Dir(&quot;/public&quot;))\tmux.Handle(&quot;/static/&quot;,http.StripPrefix(&quot;/static&quot;,file))\tmux.HandleFunc(&quot;/&quot;,index)\tserver:=&amp;http.Server&#123; Addr: &quot;0.0.0.0:8080&quot;, Handler: mux,\t&#125;\tserver.ListenAndServe()&#125;// 处理函数func index(writer http.ResponseWriter, request *http.Request) &#123;\tfmt.Fprintf(writer,&quot;hello world! url %s&quot;,request.URL)&#125; 2. FileServer123456789101112131415161718// FileServer returns a handler that serves HTTP requests// with the contents of the file system rooted at root.//// As a special case, the returned file server redirects any request// ending in &quot;/index.html&quot; to the same path, without the final// &quot;index.html&quot;.//// To use the operating system&#x27;s file system implementation,// use http.Dir:////\thttp.Handle(&quot;/&quot;, http.FileServer(http.Dir(&quot;/tmp&quot;)))//// To use an fs.FS implementation, use http.FS to convert it:////\thttp.Handle(&quot;/&quot;, http.FileServer(http.FS(fsys)))func FileServer(root FileSystem) Handler &#123;\treturn &amp;fileHandler&#123;root&#125;&#125; 123type fileHandler struct &#123; root FileSystem&#125; 12345678910// A FileSystem implements access to a collection of named files.// The elements in a file path are separated by slash (&#x27;/&#x27;, U+002F)// characters, regardless of host operating system convention.// See the FileServer function to convert a FileSystem to a Handler.//// This interface predates the fs.FS interface, which can be used instead:// the FS adapter function converts an fs.FS to a FileSystem.type FileSystem interface &#123;\tOpen(name string) (File, error)&#125; 123type Handler interface &#123; ServeHTTP(ResponseWriter, *Request)&#125; 12345678func (f *fileHandler) ServeHTTP(w ResponseWriter, r *Request) &#123;\tupath := r.URL.Path\tif !strings.HasPrefix(upath, &quot;/&quot;) &#123; upath = &quot;/&quot; + upath r.URL.Path = upath\t&#125;\tserveFile(w, r, f.root, path.Clean(upath), true)&#125; index1234567891011121314// 处理函数func index(writer http.ResponseWriter, request *http.Request) &#123;\tfmt.Fprintf(writer,&quot;hello world! url %s&quot;,request.URL)\t//刚开始的时候\tfiles := []string&#123; &quot;templates/layout.html&quot;, &quot;templates/navbar.html&quot;, &quot;templates/index.html&quot;,\t&#125;\ttemplates := template.Must(template.ParseFiles(files...))\tif threads, err := data.Threads(); err == nil &#123; templates.ExecuteTemplate(writer, &quot;layout&quot;, threads)\t&#125;&#125; 1. 添加cookie信息设置cookie信息123456789101112131415161718192021// 处理cookiefunc authenticate(w http.ResponseWriter, r *http.Request) &#123;\t// 基本逻辑是 解析请求\t// 1. 如果认证信息ok 存储cookie 并跳转到主页\t// 2. 如果认证信息file，直接跳转登录\tr.ParseForm()\tuser, _ := data.UserByEmail(r.PostFormValue(&quot;email&quot;))\tif user.Password == data.Encrypt(r.PostFormValue(&quot;password&quot;)) &#123; session, _ := user.CreateSession() cookie := http.Cookie&#123; Name: &quot;this is a cookie&quot;, Value: session.Uuid, HttpOnly: true, // 只能通过http/https进行访问 &#125; //func SetCookie(w ResponseWriter, cookie *Cookie) http.SetCookie(w, &amp;cookie) http.Redirect(w, r, &quot;/&quot;, 302)\t&#125; else &#123; http.Redirect(w, r, &quot;/login&quot;, 302)\t&#125;&#125; 验证cookie信息12345678910func session(w http.ResponseWriter, r *http.Request) (see data.Session, err error) &#123;\tcookie, err := r.Cookie(&quot;this is a cookie&quot;)\tif err == nil &#123; see = data.Session&#123;Uuid: cookie.Value&#125; if ok, _ := see.Check(); !ok &#123; err = errors.New(&quot;Invalid Session!&quot;) &#125;\t&#125;\treturn&#125; 2. 处理优化123456789101112131415161718192021222324func index(writer http.ResponseWriter, request *http.Request) &#123;\t// 优化之后\tthreads, err := data.Threads()\tif err == nil &#123; _, err := session(writer, request) public_temp_files:=[]string&#123; &quot;templates/layout.html&quot;, &quot;templates/public.navbar.html&quot;, &quot;templates/index.html&quot;, &#125; private_temp_files:=[]string&#123; &quot;templates/layout.html&quot;, &quot;templates/priavte.navbar.html&quot;, &quot;templates/index.html&quot;, &#125; var templates *template.Template if err!=nil&#123; templates=template.Must(template.ParseFiles(public_temp_files...)) &#125;else&#123; templates=template.Must(template.ParseFiles(private_temp_files...)) &#125; templates.ExecuteTemplate(writer,&quot;layout&quot;,threads)\t&#125;&#125; 3. 继续抽离123456789// 继续优化func generateHTML(w http.ResponseWriter, data interface&#123;&#125;, fn ...string) &#123;\tvar files []string\tfor _, file := range fn &#123; files = append(files, fmt.Sprintf(&quot;tempplate/%s.html&quot;, file))\t&#125;\ttemplates := template.Must(template.ParseFiles(files...))\ttemplates.ExecuteTemplate(w, &quot;layout&quot;, data)&#125; 123456789101112// 处理函数func index(writer http.ResponseWriter, request *http.Request) &#123;\tthreads, err := data.Threads()\tif err == nil &#123; _, err := session(writer, request) if err != nil &#123; generateHTML(writer, threads, &quot;layout&quot;, &quot;public.navbar&quot;, &quot;index&quot;) &#125; else &#123; generateHTML(writer, threads, &quot;layout&quot;, &quot;private.navbar&quot;, &quot;index&quot;) &#125;\t&#125;&#125;","categories":["go部分","web"]},{"title":"AVL树 | 笔记整理!","path":"/2023/07/08/AVL树/","content":"AVL树 | 笔记整理! AVL树结构体123456type AVLNode struct &#123;\tkey int\tleft *AVLNode\tright *AVLNode\theight int&#125; 定义 AVL 树节点的结构体。每个节点包含一个键值、左子节点、右子节点和当前节点的高度。 辅助函数newNode 函数用于创建一个新的 AVL 树节点，并初始化键值、左右子节点以及高度。 123func newNode(key int) *AVLNode &#123;\treturn &amp;AVLNode&#123;key: key, left: nil, right: nil, height: 1&#125;&#125; getHeight 函数用于获取指定节点的高度。如果节点为空，则返回 0。 123456func getHeight(node *AVLNode) int &#123;\tif node == nil &#123; return 0\t&#125;\treturn node.height&#125; getBalance 函数用于计算指定节点的平衡因子，即左子树的高度减去右子树的高度。如果节点为空，则返回 0。 123456func getBalance(node *AVLNode) int &#123;\tif node == nil &#123; return 0\t&#125;\treturn getHeight(node.left) - getHeight(node.right)&#125; updateHeight 函数用于更新节点的高度。它计算节点的新高度，并将其更新为左右子树中较大的高度加 1。 123func updateHeight(node *AVLNode) &#123;\tnode.height = 1 + max(getHeight(node.left), getHeight(node.right))&#125; max 函数用于返回两个整数中较大的值。 123456func max(a, b int) int &#123;\tif a &gt; b &#123; return a\t&#125;\treturn b&#125; findMinValue 函数用于找到以指定节点为根的子树中的最小值节点。它通过不断遍历左子节点，直到找到最左边的叶子节点。 1234567func findMinValue(node *AVLNode) *AVLNode &#123;\tcur := node\tfor cur.left != nil &#123; cur = cur.left\t&#125;\treturn cur&#125; printAVLTree 函数用于打印 AVL 树的结构。它采用递归方式，先打印右子树，然后打印当前节点，最后打印左子树。通过增加制表符来表示树的层级。 1234567891011121314func printAVLTree(node *AVLNode, level int) &#123;\tif node == nil &#123; return\t&#125;\tprintAVLTree(node.right, level+1)\tfor i := 0; i &lt; level; i++ &#123; fmt.Print(&quot;\\t&quot;)\t&#125;\tfmt.Printf(&quot;%d &quot;, node.key)\tprintAVLTree(node.left, level+1)&#125; 旋转操作基础旋转leftRotate 函数实现左旋操作。它将当前节点的右子节点旋转为当前节点的父节点，并更新节点的高度。 12345678func leftRotate(node *AVLNode) *AVLNode &#123;\tchild := node.right\tnode.right = child.left\tchild.left = node\tupdateHeight(node)\tupdateHeight(child)\treturn child&#125; rightRotate 函数实现右旋操作。它将当前节点的左子节点旋转为当前节点的父节点，并更新节点的高度。 12345678func rightRotate(node *AVLNode) *AVLNode &#123;\tchild := node.left\tnode.left = child.right\tchild.right = node\tupdateHeight(node)\tupdateHeight(child)\treturn child&#125; 处理旋转rotate 函数用于处理 AVL 树中的旋转操作。它检查当前节点的平衡因子，并根据情况执行左旋或右旋操作，以恢复树的平衡。 12345678910111213141516171819202122232425func rotate(node *AVLNode) *AVLNode &#123;\tbf := getBalance(node)\t//left-right\tif bf &gt; 1 &#123; //LL if childBf := getBalance(node.left); childBf &gt;= 0 &#123; return rightRotate(node) &#125; else &#123; //LR node.left = leftRotate(node.left) return rightRotate(node) &#125;\t&#125;\tif bf &lt; -1 &#123; //RR if childBf := getBalance(node.right); childBf &lt;= 0 &#123; return leftRotate(node) &#125; else &#123; //RL node.right = rightRotate(node.right) return leftRotate(node) &#125;\t&#125;\treturn node&#125; 插入insert 函数用于向 AVL 树中插入一个新节点。它按照二叉搜索树的规则找到合适的位置，并更新节点的高度，然后执行旋转操作以保持树的平衡。 123456789101112131415// 插入func insert(root *AVLNode, key int) *AVLNode &#123;\tif root == nil &#123; return newNode(key)\t&#125;\tif key &lt; root.key &#123; root.left = insert(root.left, key)\t&#125; else if key &gt; root.key &#123; root.right = insert(root.right, key)\t&#125; else &#123; return root\t&#125;\tupdateHeight(root)\treturn rotate(root)&#125; 删除remove 函数用于从 AVL 树中删除指定键值的节点。它按照二叉搜索树的规则找到要删除的节点，并根据情况进行删除操作。 1234567891011121314151617181920212223242526272829303132// 删除// 1. 如果是孤寡人 直接删除// 2. 如果只有一个孩子 孩子称为大爹 即可// 3. 如果有两个孩子 将左边孩子中最大的复制给要删除的 然后删除最大的孩子 或者将右边孩子中最小的复制给要删除的 然后删除最小的孩子func remove(root *AVLNode, key int) *AVLNode &#123;\tif root == nil &#123; return root\t&#125;\tif key &lt; root.key &#123; root.left = remove(root.left, key)\t&#125; else if key &gt; root.key &#123; root.right = remove(root.right, key)\t&#125; else &#123; if root.left == nil || root.right == nil &#123; child := root.left if root.right != nil &#123; child = root.right &#125; if child == nil &#123; return nil &#125; else &#123; root = child &#125; &#125; else &#123; cur := findMinValue(root.right) root.right = remove(root.right, cur.key) root.key = cur.key &#125;\t&#125;\tupdateHeight(root)\treturn rotate(root)&#125; 测试代码一个简单的测试代码，它演示了如何使用 AVL 树的插入和删除操作，并打印树的结构。首先，将一些节点插入树中，然后删除一些节点，并输出删除后的树结构。 1234567891011121314151617181920212223func main() &#123;\tvar root *AVLNode\t// 插入节点\troot = insert(root, 10)\troot = insert(root, 20)\troot = insert(root, 30)\troot = insert(root, 40)\troot = insert(root, 50)\troot = insert(root, 25)\t// 输出插入节点后的树结构\tfmt.Println(&quot;插入节点后的树结构：&quot;)\tprintAVLTree(root, 0)\t// 删除节点\troot = remove(root, 30)\troot = remove(root, 40)\t// 输出删除节点后的树结构\tfmt.Println(&quot;删除节点后的树结构：&quot;)\tprintAVLTree(root, 0)&#125;","categories":["考研","数"]},{"title":"单调栈","path":"/2023/05/01/单调栈/","content":"单调栈 | 笔记整理! 单调栈 | 笔记心得 2023.5.1 42 接雨水 需要进行横向拓展 方便处理优化 123456789101112class Solution: def trap(self, height: List[int]) -&gt; int: st=[] ans=0 for k,v in enumerate(height): while st and height[st[-1]]&lt;v: pre=st.pop() if st: l,r=st[-1],k ans+=(r-l-1)*(min(height[l],height[r])-height[pre]) st.append(k) return ans 84 柱状图中最大的矩形 同款思路 不断拓展 12345678910111213class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: st=[-1] heights.append(0) ans=0 for k,v in enumerate(heights): # 需要保证右边是最大的 while st and heights[st[-1]]&gt;v: pre=st.pop() dis=k-st[-1]-1 ans=max(ans,dis*heights[pre]) st.append(k) return ans 85 最大矩形 84基础上优化一下 注意是 只包含 1 的最大矩形，并返回其面积 1234567891011121314151617181920212223class Solution: def maximalRectangle(self, matrix: List[List[str]]) -&gt; int: # 理解了 类似于 84 n=len(matrix[0]) height=[0]*(n+1) ans=0 for r in matrix: for i,c in enumerate(r): # 只包含 1 的最大矩形，并返回其面积 height[i]=0 if c==&#x27;0&#x27; else height[i]+1 ans=max(ans,self.largestRectangleArea(height)) return ans def largestRectangleArea(self, heights: List[int]) -&gt; int: st=[-1] ans=0 for k,v in enumerate(heights): # 需要保证右边是最大的 while st and heights[st[-1]]&gt;v: pre=st.pop() dis=k-st[-1]-1 ans=max(ans,dis*heights[pre]) st.append(k) return ans 316 去除重复字母 注意唯一 和 字典序 1234567891011121314class Solution: def removeDuplicateLetters(self, s: str) -&gt; str: map = Counter(s) st = [] for i in s: # 保证唯一 if i in st: map[i]-=1 continue while st and st[-1]&gt;i and map[st[-1]]: st.pop() map[i]-=1 st.append(i) return &#x27;&#x27;.join(st) 321 拼接最大数 参考归并 处理所有可能 12345678910111213141516171819202122class Solution: def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -&gt; List[int]: # 有所想法 立马想到归并 # 还是无从下手 def get_big_nums(nums,k): st=[] cnt=len(nums)-k for i in nums: while cnt and st and st[-1]&lt;i: cnt-=1 st.pop() st.append(i) return st[:k] def merge_nums(a,b): ans=[] while a or b: big=a if a&gt;b else b ans.append(big.pop(0)) return ans return max(merge_nums(get_big_nums(nums1,i),get_big_nums(nums2,k-i)) for i in range(k+1) if i&lt;=len(nums1) and k-i&lt;=len(nums2)) 402 移掉k位数字 移除问题 对于位数移除之后单独考虑 1234567891011class Solution: def removeKdigits(self, num: str, k: int) -&gt; str: st=[] for i in num: while k and st and st[-1]&gt;i: k-=1 st.pop() st.append(i) # 对于位数移除之后单独考虑 st=st[:-k] if k else st return &#x27;&#x27;.join(st).lstrip(&#x27;0&#x27;) or &#x27;0&#x27; 456 132模式 本题有所参考 确实学到 处理一条之后然后完善剩余的 123456789101112131415161718class Solution: def find132pattern(self, nums: List[int]) -&gt; bool: # 先进行一遍遍历 存左边最小的 # 从后操作即可 n=len(nums) min_vals=[nums[0]]*n for i in range(1,n): min_vals[i]=min(min_vals[i-1],nums[i]) st=[] for i in range(n-1,-1,-1): nxt_val=-inf while st and st[-1]&lt;nums[i]: nxt_val=st.pop() if nxt_val&gt;min_vals[i]: return True st.append(nums[i]) return False 496 下一个更大元素I 下一个最大/小问题 12345678910111213class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: st=[] map=&#123;&#125; for k,v in enumerate(nums2): while st and nums2[st[-1]]&lt;v: idx=st.pop() map[nums2[idx]]=v st.append(k) if st:map[v]=-1 print(map) return [map[i] for i in nums1] 503 下一个更大元素 II 上一题稍微优化即可 也可以对于范围进行优化 0~2n-2即可 1234567891011class Solution: def nextGreaterElements(self, nums: List[int]) -&gt; List[int]: st=[] n=len(nums) ans=[-1]*n for i in range(2*n-1): #0~2n-1 是不行的 我们需要执行到 0~2*n-2 while st and nums[st[-1]%n]&lt;nums[i%n]: idx=st.pop() ans[idx%n]=nums[i%n] st.append(i%n) return ans 581 最短无序连续子数组 困了 直接暴力 1234567891011class Solution: def findUnsortedSubarray(self, nums: List[int]) -&gt; int: ans=sorted(nums) if ans==nums:return 0 pre=0 n=len(nums) while pre&lt;n and ans[pre]==nums[pre]:pre+=1 nxt=n-1 while nxt&gt;=0 and ans[nxt]==nums[nxt]:nxt-=1 return n-pre-(n-nxt)+1","tags":["算法笔记"],"categories":["算法笔记"]},{"title":"路径问题|dp|笔记心得","path":"/2023/02/28/路径问题-dp-笔记心得/","content":"路径问题|dp|笔记心得 | 笔记整理! 62 不同路径直接实现即可 初始数值dp[0][0]=1 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 &amp;&amp; j == 0) &#123; dp[i][j] = 1; &#125; else if (i == 0) &#123; dp[i][j] = dp[i][j - 1]; &#125; else if (j == 0) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; &#125; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;; 63 不同路径 II只是多了一个障碍!12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); // dp[i][j]=dp[i][j-1]+dp[i-1][j]; 转移方程是没有变化的 vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; // 如果不是有障碍的话 if (obstacleGrid[i][j] == 0) &#123; if (i == 0 &amp;&amp; j == 0) &#123; dp[i][j] = 1; &#125; else if (i == 0) &#123; dp[i][j] = dp[i][j - 1]; &#125; else if (j == 0) &#123; dp[i][j] = dp[i - 1][j]; &#125; else &#123; dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; &#125; &#125; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;; 64 最小路径和注意边界条件1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; // 最小路径和 对于边界点 需要单独处理一下 int m = grid.size(), n = grid[0].size(); for (int i = 0;i &lt; m;i++) &#123; for (int j = 0;j &lt; n;j++) &#123; // 判断一下边界 if (i == 0 &amp;&amp; j == 0) &#123; // 结束了 continue; &#125; else if (i == 0) &#123; grid[i][j] += grid[i][j - 1]; &#125; else if (j == 0) &#123; grid[i][j] += grid[i - 1][j]; &#125; else &#123; grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]); &#125; &#125; &#125; return grid[m - 1][n - 1]; &#125;&#125;; 120 三角形最小路径和经典实现 | 从下开始走12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; dp) &#123; // 经典模板题目了 int n = dp.size(); for (int i = n - 2;i &gt;= 0;i--) &#123; for (int j = 0;j &lt;= i;j++) &#123; dp[i][j] += min(dp[i + 1][j], dp[i + 1][j + 1]); &#125; &#125; return dp[0][0]; &#125;&#125;; 931 下降路径和和上一个题类似12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); // 从下往上开始走 for (int i = n - 2;i &gt;= 0;i--) &#123; for (int j = 0;j &lt; n;j++) &#123; // 因为是三个方向 需要判断一下大小 // 这个b和c必须设置为最大值 因为和比较的a已经不是原来的了 // 可能已经被干扰了 int a = matrix[i + 1][j], b = INT_MAX, c = INT_MAX; if (j + 1 &lt;= n - 1) &#123; b = matrix[i + 1][j + 1]; &#125; if (j &gt;= 1) &#123; c = matrix[i + 1][j - 1]; &#125; matrix[i][j] += min(a, min(b, c)); &#125; &#125; int ans = INT_MAX; for (int j = 0;j &lt; n;j++)ans = min(ans, matrix[0][j]); return ans; &#125;&#125;; 1289 下降路径和 II上一题的升级版本1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(); // 拓展有同一列了 for (int i = n - 2; i &gt;= 0; i--) &#123; // 记录最大值和最小值的索引下标 int idx1 = -1, idx2 = -1; for (int k = 0; k &lt; n; k++) &#123; int cur = grid[i + 1][k]; if (idx1 == -1 || grid[i + 1][idx1] &gt;= cur) &#123; idx2 = idx1; idx1 = k; &#125; else if (idx2 == -1 || grid[i + 1][idx2] &gt; cur) &#123; idx2 = k; &#125; &#125; for (int j = 0; j &lt; n; j++) &#123; grid[i][j] += idx1 == j ? grid[i + 1][idx2] : grid[i + 1][idx1]; &#125; &#125; int ans = INT_MAX; for (int j = 0; j &lt; n; j++) &#123; ans = min(ans, grid[0][j]); &#125; return ans; &#125;&#125;;","tags":["算法笔记"],"categories":["算法笔记","动态规划"]},{"title":"go基础操作2","path":"/2023/02/23/go基础操作2/","content":"go基础操作| web前导知识 | 笔记整理! 客户端请求做法1 | http.NewRequest ()123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport (\t&quot;fmt&quot;\t&quot;io&quot;\t&quot;net/http&quot;)func main() &#123;\ttestHttpNewRequst()&#125;func testHttpNewRequst() &#123;\t// 1.建立客户端\tclient := http.Client&#123;&#125;\t// 2.建立请求\t// method, url string, body io.Reader\treq,err:=http.NewRequest(&quot;GET&quot;,&quot;https://learnku.com/go/c/translations&quot;,nil)\tCheckErr(err)\t// 3.客户端发送请求\tresponse,err:=client.Do(req)\tCheckErr(err)\tdefer response.Body.Close() // 4.提取数据\tif response.StatusCode==200&#123; data,err:=io.ReadAll(response.Body) CheckErr(err) fmt.Println(string(data))\t&#125;else&#123; fmt.Println(&quot;网络访问失败!状态码:&quot;,response.StatusCode)\t&#125;&#125;func CheckErr(err error)&#123;\tdefer func () &#123; if ins,ok:=recover().(error);ok&#123; fmt.Println(&quot;程序异常!&quot;,ins.Error()) &#125;\t&#125;()\tif err!=nil&#123; panic(err)\t&#125;&#125; 做法2 | client. Get()1234567891011121314151617181920212223242526272829303132333435363738package mainimport (\t&quot;fmt&quot;\t&quot;io&quot;\t&quot;net/http&quot;)func main() &#123;\ttestClientGet()&#125;func testClientGet() &#123;\t// 1. 建立客户端\tclient := http.Client&#123;&#125;\t// 2. 使用客户端发起请求\tres,err:=client.Get(&quot;https://learnku.com/go/c/translations&quot;)\tCheckErr(err)\tdefer res.Body.Close()\t// 3.提取数据\tif res.StatusCode==200&#123; data,err:=io.ReadAll(res.Body) CheckErr(err) fmt.Println(string(data))\t&#125;else&#123; fmt.Println(&quot;网络访问失败!状态码:&quot;,res.StatusCode)\t&#125;&#125;func CheckErr(err error)&#123;\tdefer func () &#123; if ins,ok:=recover().(error);ok&#123; fmt.Println(&quot;程序异常!&quot;,ins.Error()) &#125;\t&#125;()\tif err!=nil&#123; panic(err)\t&#125;&#125; 做法3 | Http.Get()12345678910111213141516171819202122232425262728293031323334353637package mainimport (\t&quot;fmt&quot;\t&quot;io&quot;\t&quot;net/http&quot;)func main() &#123;\ttestClientGet()&#125;func testClientGet() &#123;\t// 1. 使用http发起请求! 还是用到的 DefaultClient 而defaultclient是\t// var DefaultClient = &amp;Client&#123;&#125;\tres,err:=http.Get(&quot;https://learnku.com/go/c/translations&quot;)\tCheckErr(err)\tdefer res.Body.Close()\t// 2. 提取数据\tif res.StatusCode==200&#123; data,err:=io.ReadAll(res.Body) CheckErr(err) fmt.Println(string(data))\t&#125;else&#123; fmt.Println(&quot;网络访问失败!状态码:&quot;,res.StatusCode)\t&#125;&#125;func CheckErr(err error)&#123;\tdefer func () &#123; if ins,ok:=recover().(error);ok&#123; fmt.Println(&quot;程序异常!&quot;,ins.Error()) &#125;\t&#125;()\tif err!=nil&#123; panic(err)\t&#125;&#125; 补充一下 post 做法 | http.NewRequest ()1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport (\t&quot;fmt&quot;\t&quot;io&quot;\t&quot;net/http&quot;\t&quot;strings&quot;)func main() &#123;\t// 测试网站总结 https://www.jianshu.com/p/cf5b0b7b5dbf\turl := &quot;https://httpbin.org/post&quot;\tdata:=strings.NewReader(&quot;This is the data to be submitted!&quot;)\ttestClientGet(url,data)&#125;func testClientGet(url string,data *strings.Reader) &#123;\t// 1. 建立客户端\tclient := http.Client&#123;&#125;\t// 2. 使用客户端发起请求\tr,err:=http.NewRequest(&quot;POST&quot;,url,data)\tCheckErr(err)\tres, err := client.Do(r)\tCheckErr(err)\tdefer res.Body.Close()\t// 3.提取数据\tif res.StatusCode == 200 &#123; data, err := io.ReadAll(res.Body) CheckErr(err) fmt.Println(string(data))\t&#125; else &#123; fmt.Println(&quot;网络访问失败!状态码:&quot;, res.StatusCode)\t&#125;&#125;func CheckErr(err error) &#123;\tdefer func() &#123; if ins, ok := recover().(error); ok &#123; fmt.Println(&quot;程序异常!&quot;, ins.Error()) &#125;\t&#125;()\tif err != nil &#123; panic(err)\t&#125;&#125; 服务端接受操作1 | http. FileServer ()123456789101112131415161718192021222324252627282930313233package mainimport &quot;net/http&quot;// 文件服务器 做法// 1. http.FileServer()搭建的服务器只提供静态文件的访问。// 因为这种web服务只支持静态文件访问// 会返回一个 http.Handler// 2. http.ListenAndServe()函数用来启动Web服务，绑定并监听http端口// ListenAndServe listens on the TCP network address addr and then calls// Serve with handler to handle requests on incoming connections.// Accepted connections are configured to enable TCP keep-alives.//// The handler is typically nil, in which case the DefaultServeMux is used.//// ListenAndServe always returns a non-nil error.// func ListenAndServe(addr string, handler Handler) error &#123;// server := &amp;Server&#123;Addr: addr, Handler: handler&#125;// return server.ListenAndServe()// &#125;// 其中headle 接口的是 实现 处理// 只需要实现了 serveHttp这个方法就是 实现了 handler接口// type Handler interface &#123;//\tServeHTTP(ResponseWriter, *Request)//&#125;func main() &#123;\ttestFileServer()&#125;func testFileServer() &#123;\thttp.ListenAndServe(&quot;:10086&quot;, http.FileServer(http.Dir(&quot;F:/go部分学习/网络开发/&quot;)))&#125; 操作2 | http.HandleFunc()12345678910111213141516171819202122232425262728293031package mainimport (\t&quot;fmt&quot;\t&quot;net/http&quot;)// http. HandleFunc()的作用是注册网络访问的路由。// 因为它采用的是默认的路由分发任务方式，所以称之为默认的多路由分发服务// HandleFunc registers the handler function for the given pattern// in the DefaultServeMux.// The documentation for ServeMux explains how patterns are matched.// func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123;// DefaultServeMux.HandleFunc(pattern, handler)// &#125;// 关于serverMux// ServeMux also takes care of sanitizing the URL request path and the Host// header, stripping the port number and redirecting any request containing . or// .. elements or repeated slashes to an equivalent, cleaner URL.func main() &#123;\thttp.HandleFunc(&quot;/index&quot;,IndexHandler)\t// The handler is typically nil, in which case the DefaultServeMux is used.\terr:=http.ListenAndServe(&quot;:10086&quot;,nil)\tfmt.Println(err)\t&#125;//handler func(ResponseWriter, *Request)func IndexHandler(w http.ResponseWriter,r *http.Request)&#123;\tfmt.Println(&quot;/index====&quot;)\tw.Write([]byte(&quot;&lt;h1&gt;默认首页信息&lt;/h1&gt;&quot;))&#125; 补充ServeMux12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ServeMux is an HTTP request multiplexer.// It matches the URL of each incoming request against a list of registered// patterns and calls the handler for the pattern that// most closely matches the URL.//// Patterns name fixed, rooted paths, like &quot;/favicon.ico&quot;,// or rooted subtrees, like &quot;/images/&quot; (note the trailing slash).// Longer patterns take precedence over shorter ones, so that// if there are handlers registered for both &quot;/images/&quot;// and &quot;/images/thumbnails/&quot;, the latter handler will be// called for paths beginning &quot;/images/thumbnails/&quot; and the// former will receive requests for any other paths in the// &quot;/images/&quot; subtree.//// Note that since a pattern ending in a slash names a rooted subtree,// the pattern &quot;/&quot; matches all paths not matched by other registered// patterns, not just the URL with Path == &quot;/&quot;.//// If a subtree has been registered and a request is received naming the// subtree root without its trailing slash, ServeMux redirects that// request to the subtree root (adding the trailing slash). This behavior can// be overridden with a separate registration for the path without// the trailing slash. For example, registering &quot;/images/&quot; causes ServeMux// to redirect a request for &quot;/images&quot; to &quot;/images/&quot;, unless &quot;/images&quot; has// been registered separately.//// Patterns may optionally begin with a host name, restricting matches to// URLs on that host only. Host-specific patterns take precedence over// general patterns, so that a handler might register for the two patterns// &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over// requests for &quot;http://www.google.com/&quot;.//// ServeMux also takes care of sanitizing the URL request path and the Host// header, stripping the port number and redirecting any request containing . or// .. elements or repeated slashes to an equivalent, cleaner URL.type ServeMux struct &#123;\tmu sync.RWMutex\tm map[string]muxEntry\tes []muxEntry // slice of entries sorted from longest to shortest.\thosts bool // whether any patterns contain hostnames&#125;type muxEntry struct &#123;\th Handler\tpattern string&#125; DefaultServeMux与ServeMux分配1234567// NewServeMux allocates and returns a new ServeMux.func NewServeMux() *ServeMux &#123; return new(ServeMux) &#125;// DefaultServeMux is the default ServeMux used by Serve.var DefaultServeMux = &amp;defaultServeMuxvar defaultServeMux ServeMux 小总结1234567891011121314151617181920212223242526272829package mainimport (\t&quot;fmt&quot;\t&quot;net/http&quot;)// http. HandleFunc()的作用是注册网络访问的路由。// 因为它采用的是默认的路由分发任务方式，所以称之为默认的多路由分发服务// 总结部分:// 这个http.NewServeMux() 生成一个自己的方案 然后自己来实现路由转发细节处理 (留给自己的)// 而DefaultServeMux的细节化操作是go已经做好了的// http.NewServeMux()仍然使用原来的结构体，只是其中的MUXEntry已经被替换为map容器。// 它可以帮助你根据不同的URL进行路由，并且能够更好地处理请求。// 显然 简单的开发是不需要这么花里胡哨的 (&lt;-自己写框架的话 可以试试)func main() &#123;\thttp.HandleFunc(&quot;/index&quot;,IndexHandler)\t// The handler is typically nil, in which case the DefaultServeMux is used.\terr:=http.ListenAndServe(&quot;:10086&quot;,nil)\tfmt.Println(err)\t// http.NewServeMux()&#125;//handler func(ResponseWriter, *Request)func IndexHandler(w http.ResponseWriter,r *http.Request)&#123;\tfmt.Println(&quot;/index====&quot;)\tw.Write([]byte(&quot;&lt;h1&gt;默认首页信息&lt;/h1&gt;&quot;))&#125; 获取客户端请求数据 Requst部分方法即可 补充Cookie结构体1234567891011121314151617181920212223// A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an// HTTP response or the Cookie header of an HTTP request.//// See https://tools.ietf.org/html/rfc6265 for details.type Cookie struct &#123;\tName string\tValue string\tPath string // optional\tDomain string // optional\tExpires time.Time // optional\tRawExpires string // for reading cookies only\t// MaxAge=0 means no &#x27;Max-Age&#x27; attribute specified.\t// MaxAge&lt;0 means delete cookie now, equivalently &#x27;Max-Age: 0&#x27;\t// MaxAge&gt;0 means Max-Age attribute present and given in seconds\tMaxAge int\tSecure bool\tHttpOnly bool\tSameSite SameSite\tRaw string\tUnparsed []string // Raw text of unparsed attribute-value pairs&#125; 附录 | 参考 | 好文 测试请求 官方文档 微信读书中go开发实战 掘金大佬","tags":["计算机,编程语言"],"categories":["go","语言基础"]},{"title":"go基础操作1","path":"/2023/02/23/go基础操作1/","content":"go基础操作| Json | 笔记整理! 转换基础转换 | Marshal + MarshalIndent1234567891011121314151617181920212223242526package mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;)func main() &#123;\td := map[string][]string&#123; &quot;name&quot;: &#123;&quot;亚索&quot;&#125;, &quot;skill&quot;: &#123;&quot;浪客之道&quot;, &quot;斩钢闪&quot;, &quot;风之障壁&quot;, &quot;踏前斩&quot;, &quot;狂风绝息斩&quot;&#125;,\t&#125;\t// 到Marshal()函数返回的JSON字符串是没有空白字符和缩进的\t// 不是很适合阅读的\tif data, err := json.Marshal(d); err == nil &#123; fmt.Printf(&quot;%s &quot;,data)\t&#125;\t// MarshalIndent is like Marshal but applies Indent to format the output.\t// Each JSON element in the output will begin on a new line beginning with prefix\t// followed by one or more copies of indent according to the indentation nesting.\t// 传入的三个参数是 这样的: v any, prefix, indent string\tif data, err := json.MarshalIndent(d,&quot;&quot;,&quot; &quot;); err == nil &#123; fmt.Printf(&quot;%s &quot;,data)\t&#125;&#125; 结构体转换 | 注意私有和公有12345678910111213141516171819202122232425package mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;)type Hero struct &#123;\tName string `json:&quot;_name&quot;`\tAge int `json:&quot;_age&quot;`\tMainskill string `json:&quot;_mainSkill&quot;`\t// 不大写的话 json转换出结果时候 不对外暴露\t// struct field addr has json tag but is not exported\taddr string `json:&quot;_addr&quot;` &#125;func main() &#123;\tYasuo := Hero&#123;&quot;亚索&quot;, 20, &quot;狂风绝息斩&quot;, &quot;艾欧尼亚&quot;&#125;\tfmt.Println(Yasuo)\tinfo, err:= json.Marshal(Yasuo)\tif err!=nil&#123; fmt.Println(&quot;出现错误!&quot;)\t&#125;\tfmt.Println(string(info))&#125; 处理匿名字段 | 继承问题12345678910111213141516171819202122232425package mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;)type User struct&#123;\tIkunLevel\tName string&#125;type IkunLevel struct&#123;\tSing int\tRap int\tDance int&#125;func main() &#123;\t// json包在解析匿名字段时，会将匿名字段的字段当成该结构体的字段处理\txiaoHeiZi:=User&#123; IkunLevel&#123;1,2,3&#125;,&quot;小黑子&quot;,\t&#125;\tfmt.Println(xiaoHeiZi)\tif data,err:=json.Marshal(xiaoHeiZi);err==nil&#123; fmt.Printf(&quot;%s &quot;,data)\t&#125;&#125; 补充 Marshal()函数只有在转换成功的时候才会返回数据，在转换的过程中需要注意。 JSON对象只支持string作为key，所以要编码一个map，必须是map[string]T这种类型（T是Go语言中的任意类型）。 channel、complex和function是不能被编码成JSON的。 指针在编码的时候会输出指针指向的内容，而空指针会输出null。 解析直接解析1234567891011121314package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)func main() &#123; // 1. 直接解析 data := `[&#123;&quot;Sing&quot;:&quot;1&quot;,&quot;Rap&quot;:&quot;2&quot;,&quot;Dance&quot;:&quot;3&quot;,&quot;Name&quot;:&quot;小黑子&quot;&#125;]` var dbgInfos []map[string]string // 字符串解析为 map切片 json.Unmarshal([]byte(data), &amp;dbgInfos) fmt.Println(dbgInfos)&#125; 结构体解析12345678910111213141516171819202122package mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;)type IkunLevel struct &#123;\tSing int\tRap int\tDance int&#125;func main() &#123;\t// 2. 结构体解析\tinfo := `[&#123;&quot;Sing&quot;:1,&quot;Rap&quot;:2,&quot;Dance&quot;:3&#125;,` + `&#123;&quot;Sing&quot;:2,&quot;Rap&quot;:2,&quot;Dance&quot;:3&#125;]`\tvar ikun []IkunLevel // 解析多个的时候开数组就行\tjson.Unmarshal([]byte(info), &amp;ikun)\tfmt.Println(ikun)&#125; 结构体嵌套 | 匿名字段解析123456789101112131415161718192021222324package mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;)type User struct &#123;\tIkunLevel\tName string&#125;type IkunLevel struct &#123;\tSing int\tRap int\tDance int&#125;func main() &#123; // 3. 结构体解析 + 嵌套!\tinfo := `&#123;&quot;Sing&quot;:1,&quot;Rap&quot;:2,&quot;Dance&quot;:3,&quot;Name&quot;:&quot;小黑子&quot;&#125;`\tvar xiaoHeiZi User\tjson.Unmarshal([]byte(info), &amp;xiaoHeiZi)\tfmt.Println(xiaoHeiZi)&#125; 附录 | 参考 | 好文 千锋教育go开发图书(微信读书) go语言官方json库","tags":["计算机,编程语言"],"categories":["go","语言基础"]},{"title":"go实现小爬虫","path":"/2023/02/23/go实现小爬虫/","content":"Go 爬虫笔记 | 笔记整理! Go 爬虫笔记基础入门 | 简单易上手网页访问12345678910111213141516171819202122func testHttpNewRequst(url string) &#123;\t// 1.建立客户端\tclient := http.Client&#123;&#125;\t// 2.建立请求\t// method, url string, body io.Reader\treq, err := http.NewRequest(&quot;GET&quot;, url, nil)\treq.Header.Add(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36&quot;)\tCheckErr(err)\t// 3.客户端发送请求\tresponse, err := client.Do(req)\tCheckErr(err)\tdefer response.Body.Close()\t// 4.提取数据\tif response.StatusCode != 200 &#123; fmt.Println(&quot;网络访问失败!状态码:&quot;, response.StatusCode)\t&#125;&#125; 使用goquery对于网页进行解析 | 其中总是会用到find和each方法| 此处是解析 百度热榜123456789dom, err := goquery.NewDocumentFromReader(response.Body)CheckErr(err)// Find gets the descendants of each element in the current set of matched// elements, filtered by a selector. It returns a new Selection object// containing these matched elements.dom.Find(&quot;.title-content-title&quot;).Each(func(i int, selection *goquery.Selection) &#123; fmt.Println(&quot;info:&quot;, selection.Text())&#125;) 为了便于每次处理err,可以直接新建一下CheckErr函数避免重复操作12345678910func CheckErr(err error) &#123;\tdefer func() &#123; if ins, ok := recover().(error); ok &#123; fmt.Println(&quot;程序异常!&quot;, ins.Error()) &#125;\t&#125;()\tif err != nil &#123; panic(err)\t&#125;&#125; 小练手 | 我要个性网壁纸爬取处理网页和原始数据 也可以只使用一个函数 看个人代码习惯 处理网页 | 使用goquery便于处理1234567891011121314151617181920212223242526// getPageUrl 解析网页 返回 *goquery.Document 数据类型 会进行close数据的// 便于网页进行解析func getPageUrl(url string) *goquery.Document &#123;\t// 1.建立客户端\tclient := http.Client&#123;&#125;\t// 2.建立请求\t// method, url string, body io.Reader\treq, err := http.NewRequest(&quot;GET&quot;, url, nil)\treq.Header.Add(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36&quot;)\tCheckErr(err)\t// 3.客户端发送请求\tresponse, err := client.Do(req)\tCheckErr(err)\tdefer response.Body.Close()\t// 4.提取数据\tif response.StatusCode != 200 &#123; fmt.Println(&quot;网络访问失败!状态码:&quot;, response.StatusCode)\t&#125;\tdoc, err := goquery.NewDocumentFromReader(response.Body)\tCheckErr(err)\treturn doc&#125; 处理原始网页 | 直接图片信息下载12345678910111213141516func getUrlContent(url string) io.ReadCloser &#123;\t// 1.建立客户端\tclient := http.Client&#123;&#125;\t// 2.建立请求\t// method, url string, body io.Reader\treq, err := http.NewRequest(&quot;GET&quot;, url, nil)\treq.Header.Add(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36&quot;)\tCheckErr(err)\t// 3.客户端发送请求\tresponse, err := client.Do(req)\tCheckErr(err)\treturn response.Body&#125; 处理第一页请求 | 解析首页 试图找到 目标详情页面1234567891011121314151617181920212223// testHttpNewRequst 进行网页解析 获取目标详情页数据信息func testHttpNewRequst(url string, page int) &#123;\tdoc := getPageUrl(url)\t// Find gets the descendants of each element in the current set of matched\t// elements, filtered by a selector. It returns a new Selection object\t// containing these matched elements.\t// 选择器或选择 因为都是txList标签开始 可以不用 | 操作\t//pMain := doc.Find(&quot;div.pMain&quot;).Find(&quot;div.txList,div.txList.listRight&quot;).Size()\tpMain := doc.Find(&quot;div.pMain div.txList&quot;)\tsz := pMain.Size()\tpMain.Each(func(i int, selection *goquery.Selection) &#123; // https://www.woyaogexing.com/touxiang/qinglv/2023/1280322.html href, _ := selection.Find(&quot;a&quot;).Attr(&quot;href&quot;) href = &quot;https://www.woyaogexing.com&quot; + href title, _ := selection.Find(&quot;a&quot;).Attr(&quot;title&quot;) fmt.Println(href, title) // 处理目标详情页面 getPicLink(href, page)\t&#125;)\tfmt.Println(sz)&#125; 处理目标详情页面 注意出入title信息时候,注意不同版本电脑对于文件(夹)建立中字符串的限制 1234567891011121314151617181920// getPicLink 获取目标详情页数据信息func getPicLink(url string, page int) &#123;\tdoc := getPageUrl(url)\tartCont := doc.Find(&quot;.contLeftA&quot;)\ttitle := artCont.Find(&quot;h1&quot;).Text()\ttitle = regexp.MustCompile(`[\\/: *?&quot;&lt;&gt;|]`).ReplaceAllString(title, &quot;_&quot;)\tfilePath := fmt.Sprintf(&quot;page%d/%s&quot;, page, title)\terr := os.MkdirAll(filePath, os.ModePerm)\tCheckErr(err)\tartCont.Find(&quot;ul.artCont.cl li.tx-img&quot;).Each(func(i int, selection *goquery.Selection) &#123; href, _ := selection.Find(&quot;a&quot;).Attr(&quot;href&quot;) href = &quot;https:&quot; + href picFile := fmt.Sprintf(&quot;%s/%d.jpeg&quot;, filePath, i+1) fmt.Println(picFile) writerToFile(picFile, href)\t&#125;)\tfmt.Println(title)&#125; 写入文件12345678910111213// writerToFile开始进行写入文件func writerToFile(path, url string) &#123;\tfile, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, os.ModePerm)\tCheckErr(err)\tcontent := getUrlContent(url)\tdefer content.Close()\treader := bufio.NewReaderSize(content, 32*1024)\twriter := bufio.NewWriter(file)\tn, err := io.Copy(writer, reader)\tCheckErr(err)\tfmt.Printf(&quot;文件:%5s 写入数据: %d 写入完成! &quot;, path, n)&#125; 进行简单爬取 | 直接goroutine 避免花里胡哨12345678910111213func test() &#123;\turl := &quot;https://www.woyaogexing.com/touxiang/qinglv/&quot;\tfor i := 1; i &lt;= 5; i++ &#123; cur := url if i &gt; 1 &#123; temp := url cur = fmt.Sprintf(&quot;%sindex_%d.html&quot;, temp, i) time.Sleep(time.Second * 1 / 2) &#125; //fmt.Println(cur) go testHttpNewRequst(cur, i)\t&#125;&#125; 主函数 可以处理goroutine信息 | 更简约 粗暴的是直接time.sleep就行 1234func main() &#123;\ttest()\ttime.Sleep(50 * time.Second)&#125; 声明:爬虫资料仅供个人学习研究使用!尊重法律法规!侵权删! 代码过长不方便展示|已上传github","tags":["go语言实践"],"categories":["go","爬虫"]},{"title":"go-Web框架实现02","path":"/2023/02/22/go-Web框架实现02/","content":"go-Web框架实现 | 笔记整理! day02 | 上下文实现上下文 | 屏蔽内部细节简化处理细节 | 提高使用的便捷 每一次对于Web服务请求,主要是访问和响应,体现在程序上就是ResponseWriter和 *Request.在这个互联请求过程还有很多其余信息,例如Request信息 12345678910111213141516171819202122232425// go官方 Request结构体type Request struct &#123;\tMethod string\tURL *url.URL\tProto string // &quot;HTTP/1.0&quot;\tProtoMajor int // 1\tProtoMinor int // 0\tHeader Header\tBody io.ReadCloser\tGetBody func() (io.ReadCloser, error)\tContentLength int64\tTransferEncoding []string\tClose bool\tHost string\tForm url.Values\tPostForm url.Values\tMultipartForm *multipart.Form\tTrailer Header\tRemoteAddr string\tRequestURI string\tTLS *tls.ConnectionState\tCancel &lt;-chan struct&#123;&#125;\tResponse *Response\tctx context.Context&#125; 我们没必要每一次传递输入和输出信息,只需要设置一个结构体和定义一组方法,来实现彼此间的交互,具体传入的参数可以是我们自己指定的.习惯上,把这样的结构体成为Context 这样一来,对外只需要暴露接口,简化了使用的复杂度.要求我们在内部实现即可 Context内部实现ConText结构体 我们对于Context可以先补充部分信息,例如 12345678910type Context struct &#123;\t// 在之前的使用里面 这两个 用w 和 r代替\t// 接受到和要处理的\tWriter http.ResponseWriter\tReq *http.Request\tPath, Method string\tStatusCode int&#125; Context实现的方法 newContext 12345678func newContext(w http.ResponseWriter, r *http.Request) *Context &#123;\treturn &amp;Context&#123; Writer: w, Req: r, Path: r.URL.Path, Method: r.Method,\t&#125;&#125; PostForm 1234// PostForm 直接调用FormValue 以下类似func (c *Context) PostForm(key string) string &#123;\treturn c.Req.FormValue(key)&#125; Query 12345678// Query 中调用GET方法// Get gets the first value associated with the given key.// If there are no values associated with the key, Get returns// the empty string. To access multiple values, use the map// directly.func (c *Context) Query(key string) string &#123;\treturn c.Req.URL.Query().Get(key)&#125; Status 1234567// Status 调用WriteHeader 方法// WriteHeader sends an HTTP response header with the provided// status code.func (c *Context) Status(code int) &#123;\tc.StatusCode = code\tc.Writer.WriteHeader(code)&#125; SetHeader 1234// SetHeader 一下方法实现 同上思路func (c *Context) SetHeader(key, value string) &#123;\tc.Writer.Header().Set(key, value)&#125; String | JSON |Data | HTML 123456789101112131415161718192021222324252627282930func (c *Context) String(code int, format string, values ...interface&#123;&#125;) &#123;\t// 调用刚写好的方法\tc.SetHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;)\tc.Status(code)\t// 格式化 fmt.Sprintf的两个参数 format string, a ...any\tc.Writer.Write([]byte(fmt.Sprintf(format, values)))&#125;func (c *Context) JSON(code int, obj interface&#123;&#125;) &#123;\tc.SetHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)\tc.Status(code)\tval := json.NewEncoder(c.Writer)\tif err := val.Encode(obj); err != nil &#123; // http.Error所需要的参数 w ResponseWriter, error string, code int http.Error(c.Writer, err.Error(), 500)\t&#125;&#125;func (c *Context) Data(code int, data []byte) &#123;\tc.Status(code)\t// http.ResponseWriter 需要给回复的信息\tc.Writer.Write(data)&#125;func (c *Context) HTML(code int, html string) &#123;\tc.SetHeader(&quot;Content-Type&quot;, &quot;text/html&quot;)\tc.Status(code)\tc.Writer.Write([]byte(html))&#125; 优化Engine | 在实现上下文的基础上 只是在部分函数上进行优化处理即可 Engine结构体 我们对于Engine可以直接存储router指针 HandleFunc可以直接由*Context代替http.ResponseWriter,和 *http.Request简化实现 123456// 处理函数type HandleFunc func(*Context)type Engine struct &#123;\trouter *router&#125; Engine实现的方法 New 123func New() *Engine &#123;\treturn &amp;Engine&#123;router: newRounter()&#125;&#125; GET和POST方法不需要改变 123456789// get方法实现func (engine *Engine) GET(pattern string, handler HandleFunc) &#123;\tengine.addRoute(&quot;GET&quot;, pattern, handler)&#125;// post方法实现func (engine *Engine) POST(pattern string, handler HandleFunc) &#123;\tengine.addRoute(&quot;POST&quot;, pattern, handler)&#125; ServeHTTP | handler中的接口方法 12345678910// run 开始运行func (engine *Engine) Run(addr string) (err error) &#123;\treturn http.ListenAndServe(addr, engine)&#125;// 直接给出上下文环境 让路由自己实现的 handle 方法 处理上下文 即可func (engine *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\tc := newContext(w, r)\tengine.router.handle(c)&#125; Router| 路由设置 优化处理了一下 上下文 ,自然在 建立路由过程之中,首要的实现绑定路由 其次是处理方法HandleFunc Router 结构体 我们对于router先完善最重要的信息,路径和实现方法 123type router struct &#123;\thandlers map[string]HandleFunc&#125; Router 实现的方法 newRounter | 建立新的路由 123func newRounter() *router &#123;\treturn &amp;router&#123;handlers: make(map[string]HandleFunc)&#125;&#125; addRouter | 增加路由 1234func (r *router) addRouter(method, pattern string, handler HandleFunc) &#123;\tkey := method + &quot;-&quot; + pattern\tr.handlers[key] = handler&#125; handle | 进行路由匹配,如果不存在则表示404 123456789func (r *router) handle(c *Context) &#123;\t// 对应上文的\tkey := c.Method + &quot;-&quot; + c.Path\tif handler, err := r.handlers[key]; err &#123; handler(c)\t&#125; else &#123; c.String(http.StatusNotFound, &quot;404 NOT FOUND:%s &quot;, c.Path)\t&#125;&#125; 完整代码比较长 | 存储于Github仓库 附录 | 参考 | 好文 七天动手实现go-web框架 官方文档 微信读书中go开发实战 go框架-Ez","tags":["go"],"categories":["go","web框架"]},{"title":"go-Web框架实现01","path":"/2023/02/21/go-Web框架实现01/","content":"go-Web框架实现 | 笔记整理! day01 | 基础实现方法绑定 | 参考官方实现http.HandleFunc | go官方文档 会传入两个参数 | 匹配模式和处理方法 然后交给DefaultServeMux的HandleFunc函数来实现模式匹配处理 其中这个 DefaultServeMux是go官方实现的 需要我们自己进行重现一下 123456// HandleFunc registers the handler function for the given pattern// in the DefaultServeMux.// The documentation for ServeMux explains how patterns are matched.func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) &#123; DefaultServeMux.HandleFunc(pattern, handler)&#125; 其中我们对于DefaultServeMux结构体进行识别 会发现他的原始是 12345678910111213141516type ServeMux struct &#123;\tmu sync.RWMutex\tm map[string]muxEntry\tes []muxEntry // slice of entries sorted from longest to shortest.\thosts bool // whether any patterns contain hostnames&#125;type muxEntry struct &#123;\th Handler\tpattern string&#125;// DefaultServeMux is the default ServeMux used by Serve.var DefaultServeMux = &amp;defaultServeMuxvar defaultServeMux ServeMux 我们自己可以仿照go文档自己实现一个类似的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 处理函数type HandleFunc func(http.ResponseWriter, *http.Request)// 官方实现的 比较全面 &lt;-自己来手动写一个 基础的//type ServeMux struct &#123;//\tmu sync.RWMutex//\tm map[string]muxEntry//\tes []muxEntry // slice of entries sorted from longest to shortest.//\thosts bool // whether any patterns contain hostnames//&#125;////type muxEntry struct &#123;//\th Handler//\tpattern string//&#125;type Engine struct &#123;\trouter map[string]HandleFunc&#125;func New() *Engine &#123;\treturn &amp;Engine&#123;router: make(map[string]HandleFunc)&#125;&#125;// 内部使用的func (engine *Engine) addRounte(method string, pattern string, handler HandleFunc) &#123;\tkey := method + &quot;-&quot; + pattern\tengine.router[key] = handler&#125;// get方法实现func (engine *Engine) GET(pattern string, handler HandleFunc) &#123;\tengine.addRounte(&quot;GET&quot;, pattern, handler)&#125;// post方法实现func (engine *Engine) POST(pattern string, handler HandleFunc) &#123;\tengine.addRounte(&quot;POST&quot;, pattern, handler)&#125;// run 开始运行func (engine *Engine) Run(addr string) (err error) &#123;\treturn http.ListenAndServe(addr, engine)&#125; ListenAndServe | 参数接口实现 查看go官方文档,不难发现 1234567891011// ListenAndServe listens on the TCP network address addr and then calls// Serve with handler to handle requests on incoming connections.// Accepted connections are configured to enable TCP keep-alives.//// The handler is typically nil, in which case the DefaultServeMux is used.//// ListenAndServe always returns a non-nil error.func ListenAndServe(addr string, handler Handler) error &#123;\tserver := &amp;Server&#123;Addr: addr, Handler: handler&#125;\treturn server.ListenAndServe()&#125; 其中有一个参数是 handler类型是Handler. 123456789101112131415161718192021222324252627// A Handler responds to an HTTP request.//// ServeHTTP should write reply headers and data to the ResponseWriter// and then return. Returning signals that the request is finished; it// is not valid to use the ResponseWriter or read from the// Request.Body after or concurrently with the completion of the// ServeHTTP call.//// Depending on the HTTP client software, HTTP protocol version, and// any intermediaries between the client and the Go server, it may not// be possible to read from the Request.Body after writing to the// ResponseWriter. Cautious handlers should read the Request.Body// first, and then reply.//// Except for reading the body, handlers should not modify the// provided Request.//// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes// that the effect of the panic was isolated to the active request.// It recovers the panic, logs a stack trace to the server error log,// and either closes the network connection or sends an HTTP/2// RST_STREAM, depending on the HTTP protocol. To abort a handler so// the client sees an interrupted response but the server doesn&#x27;t log// an error, panic with the value ErrAbortHandler.type Handler interface &#123;\tServeHTTP(ResponseWriter, *Request)&#125; 而这是一个interface类型的 需要我们来实现其中的方法ServeHTTP,其中官方文档中的一个实现方式是 12345678910111213// ServeHTTP dispatches the request to the handler whose// pattern most closely matches the request URL.func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) &#123;\tif r.RequestURI == &quot;*&quot; &#123; if r.ProtoAtLeast(1, 1) &#123; w.Header().Set(&quot;Connection&quot;, &quot;close&quot;) &#125; w.WriteHeader(StatusBadRequest) return\t&#125;\th, _ := mux.Handler(r)\th.ServeHTTP(w, r)&#125; 我们为了达到自己实现目的,进行简单的类型匹配~(可以直接简化实现) 12345678910111213func (engine *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\tswitch r.URL.Path &#123;\tcase &quot;/&quot;: fmt.Fprintf(w, &quot;URL.Path = %q &quot;, r.URL.Path)\tcase &quot;/hello&quot;: for k, v := range r.Header &#123; fmt.Fprintf(w, &quot;Header[%q] = %q &quot;, k, v) &#125;\tdefault: fmt.Fprintf(w, &quot;404 NOT FOUND: %s &quot;, r.URL)\t&#125;&#125; 区别对待参考 | 系统 + 自己 | 完整代码!原本 //main.go 12345678910111213141516171819202122232425// main.gopackage mainimport (\t&quot;fmt&quot;\t&quot;log&quot;\t&quot;net/http&quot;)func main() &#123;\thttp.HandleFunc(&quot;/&quot;, indexHandler)\thttp.HandleFunc(&quot;/hello&quot;, helloHandler)\tlog.Fatal(http.ListenAndServe(&quot;:9999&quot;, nil))&#125;// indexHandlerfunc indexHandler(w http.ResponseWriter, r *http.Request) &#123;\tfmt.Fprintf(w, &quot;URL.Path ==%q &quot;, r.URL.Path)&#125;// hellohandlerfunc helloHandler(w http.ResponseWriter, r *http.Request) &#123;\tfor k, v := range r.Header &#123; fmt.Fprintf(w, &quot;Header[%q] = %q &quot;, k, v)\t&#125;&#125; 自己实现 // base3/main.go 123456789101112131415161718192021222324252627// base3/main.gopackage mainimport (\t&quot;fmt&quot;\t&quot;net/http&quot;\t&quot;yasuo&quot; // 自己写的模块)func main() &#123;\tr := yasuo.New()\tr.GET(&quot;/&quot;, indexHandler)\tr.GET(&quot;/hello&quot;, helloHandler)\tr.Run(&quot;:9999&quot;)&#125;// indexHandler 此处为空函数也是可以 因为匹配结果处理 ServeHTTP 已经实现func indexHandler(w http.ResponseWriter, r *http.Request) &#123;\tfmt.Fprintf(w, &quot;URL.Path ==%q &quot;, r.URL.Path)&#125;// hellohandler 理由同上!func helloHandler(w http.ResponseWriter, r *http.Request) &#123;\tfor k, v := range r.Header &#123; fmt.Fprintf(w, &quot;Header[%q] = %q &quot;, k, v)\t&#125;&#125; // base3/yasuo/yasuo.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// base3/yasuo/yasuo.gopackage yasuoimport (\t&quot;fmt&quot;\t&quot;net/http&quot;)// 处理函数type HandleFunc func(http.ResponseWriter, *http.Request)// 官方实现的 比较全面 &lt;-自己来手动写一个 基础的//type ServeMux struct &#123;//\tmu sync.RWMutex//\tm map[string]muxEntry//\tes []muxEntry // slice of entries sorted from longest to shortest.//\thosts bool // whether any patterns contain hostnames//&#125;//type muxEntry struct &#123;//\th Handler//\tpattern string//&#125;type Engine struct &#123;\trouter map[string]HandleFunc&#125;func New() *Engine &#123;\treturn &amp;Engine&#123;router: make(map[string]HandleFunc)&#125;&#125;// 内部使用的func (engine *Engine) addRounte(method string, pattern string, handler HandleFunc) &#123;\tkey := method + &quot;-&quot; + pattern\tengine.router[key] = handler&#125;// get方法实现func (engine *Engine) GET(pattern string, handler HandleFunc) &#123;\tengine.addRounte(&quot;GET&quot;, pattern, handler)&#125;// post方法实现func (engine *Engine) POST(pattern string, handler HandleFunc) &#123;\tengine.addRounte(&quot;POST&quot;, pattern, handler)&#125;// run 开始运行func (engine *Engine) Run(addr string) (err error) &#123;\treturn http.ListenAndServe(addr, engine)&#125;// 因为 http.ListenAndServe 第二个参数是 handle是一个接口 接口实现了ServeHTTP// 需要我们自己来实现一下 ServeHTTP////\ttype Handler interface &#123;// ServeHTTP(ResponseWriter, *Request)//\t&#125;func (engine *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;\tswitch r.URL.Path &#123;\tcase &quot;/&quot;: fmt.Fprintf(w, &quot;URL.Path = %q &quot;, r.URL.Path)\tcase &quot;/hello&quot;: for k, v := range r.Header &#123; fmt.Fprintf(w, &quot;Header[%q] = %q &quot;, k, v) &#125;\tdefault: fmt.Fprintf(w, &quot;404 NOT FOUND: %s &quot;, r.URL)\t&#125;\tmt := &quot;GET&quot; + &quot;-&quot; + r.URL.Path\tfmt.Println(engine.router[r.URL.Path], mt, engine.router[mt])&#125; 附录 | 参考 | 好文 七天动手实现go-web框架 官方文档 微信读书中go开发实战 go框架-Ez","tags":["go"],"categories":["go","web框架"]},{"title":"第一次出现的数字","path":"/2023/02/19/第一次出现的数字/","content":"第一次出现的数字 | 笔记整理! 只出现一次的数字 |异或的性质 | 参考百度异或的性质 1234567func singleNumber(nums []int) int &#123; ans:=0 for _,v := range nums&#123; ans^=v &#125; return ans&#125; 只出现一次的数字 ||进行映射即可 | 处理一下溢出问题12345678910111213141516func singleNumber(nums []int) int &#123;\tans ,k:= 0,3\tfor i := 0; i &lt; 32; i++ &#123; cnt:= 0 mask:=1&lt;&lt;i for _,v :=range nums&#123; if v&amp;mask&gt;0&#123; cnt++ &#125; &#125; if cnt%k&gt;0&#123; ans|=mask &#125;\t&#125;\treturn int(int32(ans))&#125; 只出现一次的数字 III还是利用异或 将所有数据异或一次 结果得到ans=a^b 其中a与b是我们需要求解的数据 显然ans是不能等于1的,我们可以对于ans区别划分 因为a与b至少有一位是不一样的,所以我们可以随便取一位不一样的 进行将所有数据区分.然后重新异或该位为1或0的数据 得到a与b中的其中一个 然后异或一下ans便可以得到最终答案! 求取不一样某位不一样的1我们可以使用补码原理,快速处理直接找到最低位的1即可 1234567891011121314func singleNumber(nums []int) []int &#123; ans:=0 for _,v:=range nums&#123; ans^=v &#125; pre:=ans&amp;(-ans) tmp:=0 for _,v:=range nums&#123; if v&amp;pre&gt;0&#123; tmp^=v &#125; &#125; return []int&#123;tmp,ans^tmp&#125;&#125;","tags":["算法笔记"],"categories":["算法笔记","有趣的题"]},{"title":"前缀和习题","path":"/2023/02/19/前缀和习题/","content":"前缀和习题 | 笔记整理! 209123456789101112131415161718192021// 使用滑动窗口思路func minSubArrayLen(target int, nums []int) int &#123; l := 0 n := len(nums) ans := n + 1 pre := 0 for r, v := range nums &#123; pre += v for pre &gt;= target &#123; if r-l+1 &lt; ans &#123; ans = r - l + 1 &#125; pre -= nums[l] l++ &#125; &#125; if ans == n+1 &#123; return 0 &#125; return ans&#125; 32512345678910111213141516171819package preSumfunc maxSubArrayLen(nums []int, k int) int &#123; ans := 0 d := map[int]int&#123;0: -1&#125; pre := 0 for r, v := range nums &#123; pre += v if idx, err := d[pre-k]; err &#123; if r-idx &gt; ans &#123; ans = r - idx &#125; &#125; if _, err := d[pre]; !err &#123; d[pre] = r &#125; &#125; return ans&#125; 523123456789101112131415161718192021package preSum// 连续的子数组和func checkSubarraySum(nums []int, k int) bool &#123; // 此处是有一个定理的 // 同余定理 // (x+y)%6 d := map[int]int&#123;0: -1&#125; pre := 0 for r, v := range nums &#123; pre = (pre + v) % k if idx, err := d[pre]; err &#123; if r-idx &gt;= 2 &#123; return true &#125; &#125; else &#123; d[pre] = r &#125; &#125; return false&#125; 525 12345678910111213141516171819202122package preSumfunc findMaxLength(nums []int) int &#123; ans := 0 d := map[int]int&#123;0: -1&#125; pre := 0 for k, v := range nums &#123; if v == 1 &#123; pre++ &#125; else &#123; pre-- &#125; if idx, err := d[pre]; err &#123; if k-idx &gt; ans &#123; ans = k - idx &#125; &#125; else &#123; d[pre] = k &#125; &#125; return ans&#125; 56012345678910111213141516package preSumfunc subarraySum(nums []int, k int) int &#123; ans := 0 d := map[int]int&#123;0: 1&#125; pre := 0 for _, v := range nums &#123; pre += v if cnt, err := d[pre-k]; err &#123; ans += cnt &#125; d[pre]++ &#125; return ans&#125; 561123456789101112package preSumimport &quot;sort&quot;func arrayPairSum(nums []int) int &#123; sort.Ints(nums) ans := 0 for i := 0; i &lt; len(nums); i += 2 &#123; ans += nums[i] &#125; return ans&#125; 713123456789101112131415161718package preSumfunc numSubarrayProductLessThanK(nums []int, k int) int &#123; ans := 0 l := 0 pre := 1 for r, v := range nums &#123; pre *= v for l &lt;= r &amp;&amp; pre &gt;= k &#123; pre /= nums[l] l++ &#125; if pre &lt; k &#123; ans += r - l + 1 &#125; &#125; return ans&#125; 9741234567891011121314151617181920package preSum// 和可被 K 整除的子数组// 优秀参考// https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/809758/shu-zu-zheng-chu-wen-ti-hui-zong-qian-zh-xzjc/func subarraysDivByK(nums []int, k int) int &#123; // (x+y)%k==0 d := map[int]int&#123;0: 1&#125; ans := 0 pre := 0 for _, v := range nums &#123; pre += v // go语言取模 会出现负数 --&gt;处理为 (pre%k+k)%k d[(pre%k+k)%k] += 1 &#125; for _, v := range d &#123; ans += v * (v - 1) / 2 &#125; return ans&#125; 11771234567891011121314151617181920package preSumfunc canMakePaliQueries(s string, queries [][]int) []bool &#123; nums := []int&#123;0&#125; for k, v := range s &#123; nums = append(nums, nums[k]^(1&lt;&lt;(int(v)-97))) &#125; ans := []bool&#123;&#125; for _, v := range queries &#123; l, r, k := v[0], v[1], v[2] ans = append(ans, func(num int) (res int) &#123; for num &gt; 0 &#123; res += num &amp; 1 num &gt;&gt;= 1 &#125; return &#125;(nums[l]^nums[r+1])/2 &lt;= k) &#125; return ans&#125; 159012345678910111213141516171819202122232425262728293031323334package preSum// 1590. 使数组和能被 P 整除func minSubarray(nums []int, p int) int &#123; // (s-sub)%p==0--&gt;s%p==sub%p s := 0 for _, v := range nums &#123; s += v &#125; tmp := s % p if tmp == 0 &#123; return 0 &#125; d := map[int]int&#123;0: -1&#125; pre := 0 n := len(nums) ans := n for r, v := range nums &#123; pre += v cur, pre := pre%p, (pre-tmp+p)%p if idx, err := d[pre]; err &#123; dis := r - idx if ans &gt; dis &#123; ans = dis &#125; &#125; d[cur] = r &#125; if ans == n &#123; return -1 &#125; return ans&#125;","tags":["算法笔记"],"categories":["算法笔记","基础算法"]},{"title":"前缀和 | 差分理论知识","path":"/2023/02/19/前缀和/","content":"前缀和|差分理论 | 笔记整理! 前缀和一维前缀和1234567891011121314151617package preSum// 力扣303type NumArray struct &#123;\tarr []int&#125;func Constructor(nums []int) NumArray &#123;\tnum := NumArray&#123;arr: []int&#123;0&#125;&#125;\tfor k, v := range nums &#123; num.arr = append(num.arr, num.arr[k]+v)\t&#125;\treturn num&#125;func (this *NumArray) SumRange(left int, right int) int &#123;\treturn this.arr[right] - this.arr[left-1]&#125; 二维前缀和1234567891011121314151617181920212223242526package preSum// 力扣304type NumMatrix struct &#123; preSum [][]int&#125;func Constructor(matrix [][]int) NumMatrix &#123;\tm,n:=len(matrix),len(matrix[0])\tpresum:=make([][]int,m+1)\tfor i:=0;i&lt;=m;i++&#123; presum[i]=make([]int, n+1)\t&#125;\tfor i:=0;i&lt;=m;i++&#123; for j:=0;j&lt;=n;j++&#123; presum[i+1][j+1]=presum[i+1][j]+presum[i][j+1]-presum[i][j]+matrix[i][j] &#125;\t&#125;\treturn NumMatrix&#123;preSum: presum&#125;&#125;func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int &#123;\tcur:=this.preSum\treturn cur[row2+1][col2+1]-cur[row2+1][col1]-cur[row1][col2+1]+cur[row1][col1]&#125; 差分一维差分1234567891011121314package Diff// 力扣 370func getModifiedArray(length int, updates [][]int) []int &#123;\tdiff:=make([]int,length+1)\tfor _,v :=range updates&#123; l,r,d:=v[0],v[1],v[2] diff[l]+=d diff[r+1]-=d\t&#125;\tfor i:=1;i&lt;length;i++&#123; diff[i]+=diff[i-1]\t&#125;\treturn diff[:length]&#125; 二维查分12345678910111213141516171819202122232425262728293031323334package Diff// 力扣2536func rangeAddQueries(n int, queries [][]int) [][]int &#123; diff:=make([][]int,n+1)\tfor i:=0;i&lt;=n;i++&#123; diff[i]=make([]int, n+1)\t&#125;\tfor _,q:=range queries&#123; r1,c1,r2,c2,x:=q[0],q[1],q[2],q[3],1 r2++ c2++ diff[r1][c1]+=x diff[r2][c1]-=x diff[r1][c2]-=x diff[r2][c2]+=x\t&#125;\t// 还原原数组\tans:=make([][]int,n+1)\tfor i:=0;i&lt;=n;i++&#123; ans[i]=make([]int, n+1)\t&#125;\tfor i:=0;i&lt;n;i++&#123; for j:=0;j&lt;n;j++&#123; ans[i+1][j+1]=ans[i+1][j]+ans[i][j+1]-ans[i][j]+diff[i][j] &#125;\t&#125;\tans=ans[1:]\tfor k,_ :=range ans&#123; ans[k]=ans[k][1:]\t&#125;\treturn ans&#125; 参考 | 好文 面试必会的算法题——前缀和 - 掘金 (juejin.cn) 啥是前缀和呀？图解前缀和（含模板）| Java 刷题打卡 - 掘金 (juejin.cn) 二维差分灵佬视频讲解 二维差分灵佬讲解","tags":["算法笔记"],"categories":["算法笔记","基础算法"]},{"title":"go类内实现","path":"/2023/02/07/go类内实现/","content":"o类内实现 | 笔记整理! 封装基本操作123456789101112131415161718192021222324252627282930313233package main import &quot;fmt&quot; // Person类 绑定方法:eat run laugh 成员 type Person struct &#123; name string age int gender string score float64 &#125; // 在外边绑定方法 +()func (this *Person) Eat() &#123; fmt.Println(&quot;Person is eating&quot;) fmt.Println(this.name + &quot; is eating !&quot;) this.name = &quot;yongen&quot; fmt.Println(this.name + &quot; is eating !&quot;) &#125; func (this Person) Eat2() &#123; // 指针才会改编数据 单纯赋值是不会修改的原数据的 fmt.Println(&quot;Person is eating&quot;) fmt.Println(this.name + &quot; is eating !&quot;) this.name = &quot;yongen&quot; fmt.Println(this.name + &quot; is eating !&quot;) &#125; func main() &#123; yasuo := Person&#123;&quot;yasuo&quot;, 30, &quot;male&quot;, 100&#125; fmt.Println(yasuo) yasuo.Eat() fmt.Println(yasuo) &#125; 继承基本操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546package main import &quot;fmt&quot; type Person struct &#123; name string age int gender string score float64 &#125; // 嵌套一个 persontype Std struct &#123; per Person school string &#125; // 继承是直接来写就行 没有字段名字 type Teacher struct &#123; Person subject string &#125; func (this *Person) Eat() &#123; fmt.Println(&quot;I&#x27;m ,&quot;, this.name) &#125; func main() &#123; s1 := Std&#123; per: Person&#123;&quot;yasuo&quot;, 16, &quot;male&quot;, 100&#125;, school: &quot;aiouniya&quot;, &#125; fmt.Println(s1.per, s1.school) // 继承 // 可以这样来操作 //t1 := Teacher&#123; // Person: Person&#123;&quot;yongen&quot;, 18, &quot;male&quot;, 100&#125;, // subject: &quot;Chinese&quot;, //&#125; t1 := Teacher&#123;&#125; t1.subject = &quot;Math&quot; t1.name = &quot;ikun&quot; t1.Eat() // 特殊用法 // 继承的时候 我们没有定义字段名字 但是会创建一个同名字段 // 为了在自雷中依然可以操作父类 因为子类父类可能出现同名的字段 fmt.Println(&quot;t1.Person.name&quot;, t1.Person.name) &#125; 访问权限文件树123456789文件夹 PATH 列表卷序列号为 4829-01C8C:.├─.idea├─class├─inherit└─polymorphic ├─.idea └─src src/fun.go12345678910111213141516171819202122232425package src import &quot;fmt&quot; type Person struct &#123; Name string Age int Gender string Score float64 &#125; // 嵌套一个 persontype Std struct &#123; Per Person School string &#125; // 继承是直接来写就行 没有字段名字 type Teacher struct &#123; Person Subject string &#125; func (this *Person) Eat() &#123; fmt.Println(&quot;I&#x27;m ,&quot;, this.Name) &#125; main.go1234567891011121314151617181920212223242526package main import ( &quot;fmt&quot; &quot;polymorphic/src&quot;) func main() &#123; s1 := src.Std&#123; Per: src.Person&#123;&quot;yasuo&quot;, 16, &quot;male&quot;, 100&#125;, School: &quot;aiouniya&quot;, &#125; fmt.Println(s1.Per, s1.School) // 继承 // 可以这样来操作 //t1 := Teacher&#123; // Person: Person&#123;&quot;yongen&quot;, 18, &quot;male&quot;, 100&#125;, // subject: &quot;Chinese&quot;, //&#125; t1 := src.Teacher&#123;&#125; t1.Subject = &quot;Math&quot; t1.Name = &quot;ikun&quot; t1.Eat() // 特殊用法 // 继承的时候 我们没有定义字段名字 但是会创建一个同名字段 // 为了在自雷中依然可以操作父类 因为子类父类可能出现同名的字段 fmt.Println(&quot;t1.Person.name&quot;, t1.Person.Name) &#125; 多态前导知识 | interface1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package main import &quot;fmt&quot; // c++中实现接口 纯虚构函数代替接口 // go语言有专门的关键字 interface 来代替接口 // 不仅仅用于处理多态 介意接受任意的数据类型 类似于void func main() &#123; fmt.Println(&quot;&quot;) //定义 接口 var i, j, k interface&#123;&#125; name := []string&#123;&quot;yasuo&quot;, &quot;yongen&quot;&#125; i = name fmt.Println(&quot;i behalf of arr:&quot;, i) i2 := 20 age := i2 j = age fmt.Println(&quot;j behalf of num:&quot;, j) str := &quot;hello world&quot; k = str fmt.Println(&quot;k behalf of string:&quot;, k) // 我们现在只知道 k是 interface 但不知道他的明确类型 // 需要一种判断 --&gt;断言 value, ok := k.(int) if !ok &#123; fmt.Println(&quot;type is not int&quot;) &#125; else &#123; fmt.Println(&quot;key value is&quot;, value) &#125; // 使用场景 把 interface当做一个函数的参数 类似于 print ,使用switch 来判断用户输入的类型 // 根据类型 来进行处理 // 创建一个具有三个接口类型的切片 arr := make([]interface&#123;&#125;, 3) arr[0] = 10086 arr[1] = &quot;yasuo&quot; arr[2] = true for _, v := range arr &#123; // 可以去除当前接口真正数据类型 switch v := v.(type) &#123; case int: fmt.Println(&quot;type is int ,value is&quot;, v) case bool: fmt.Println(&quot;type is bool ,value is&quot;, v) case string: fmt.Println(&quot;type is string ,value is&quot;, v) default: fmt.Println(&quot;type is not find&quot;) &#125; &#125; &#125; 多态实现 定义一个接口 里面设计好需要的接口 (可以有多个)任何实现了这个接口的类型 都可以赋值给这个接口 从而实现多态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package main import &quot;fmt&quot; // 实现go多态 需要实现定义接口 // 注意类型是 interfacetype IAttack interface &#123; // 接口可以有多个 但只能有一个函数原型 Attack() &#125; // 低等级 type PersonLowLevel struct &#123; name string level int &#125; // 高等级 type PersonHighLevel struct &#123; name string level int &#125; func (a *PersonLowLevel) Attack() &#123; fmt.Println(&quot;I&#x27;m&quot;, a.name, &quot;and level is&quot;, a.level, &quot;causing harm&quot;, a.level*50) &#125; func (a *PersonHighLevel) Attack() &#123; fmt.Println(&quot;I&#x27;m&quot;, a.name, &quot;and level is&quot;, a.level, &quot;causing harm&quot;, a.level*90) &#125; // 定义一个多态的接口 传入不同的对象 调用同样的方法 func DoAttack(a IAttack) &#123; a.Attack() &#125; func main() &#123; var player IAttack // 空接口 lowLevel := PersonLowLevel&#123; name: &quot;yasuo&quot;, level: 1, &#125; lowLevel.Attack() // 对于player进行赋值 // 任何一个实现了接口的 都可以使用这个方法 // 接口需要通过指针进行赋值 player = &amp;lowLevel fmt.Println(player) player.Attack() highLevel := PersonHighLevel&#123; name: &quot;yongen&quot;, level: 10, &#125; //highLevel.Attack() player = &amp;highLevel highLevel.Attack() DoAttack(&amp;lowLevel) DoAttack(&amp;highLevel) &#125;","tags":["计算机","编程语言"],"categories":["go","语言基础"]},{"title":"go语言入门","path":"/2023/02/07/go语言入门/","content":"go语言入门 | 笔记整理! 基础部分变量12345678910111213// 变量赋值手法func test() &#123;\t// 1.定义\tvar name string\tname = &quot;yasuo&quot;\t// 2.定义时直接复制\tvar city = &quot;yasuo&quot;\t// 3.自动推导\tans := 100\t// 4.平行复制\ti, j := 10, 20\tfmt.Println(&quot;变量赋值手法! &quot;, name, city, ans, i, j)&#125; 自增自检12345678// 自增 自减 (必须单独一行)不支持三目运算符func test02() &#123;\ti := 20\ti++\tfmt.Println(&quot;i:&quot;, i)\ti--\tfmt.Println(&quot;i:&quot;, i)&#125; 指针12345678910111213141516171819202122232425262728// 可以返回栈上的指针func testPtr() *string &#123;\tname := &quot;yasuo&quot;\treturn &amp;name&#125;func main() &#123;\ttest()\ttest02()\t// 指针部分 (垃圾回收机制 开发人员不是过分需要手动释放内存\t// go支持返回栈上指针 (内存逃逸\t// 指针为空nil\t// 1.直接分配\tname := &quot;yasuo&quot;\tptr := &amp;name\tfmt.Println(&quot;name&quot;, ptr, *ptr)\t// 2.new进行分配\tnamePtr := new(string)\t*namePtr = &quot;yasuo&quot;\tfmt.Println(&quot;name&quot;, namePtr, *namePtr)\t// 3.栈上指针 返回 (编译器会进行操作的\tans := testPtr()\tif ans == nil &#123; fmt.Println(&quot;指针为空&quot;)\t&#125;\tfmt.Println(&quot;栈上指针:&quot;, ans, *ans)&#125; 不支持的操作 不支持++i,--i 不支持地址加减 不支持三目运算符 只有false才能代表代码逻辑为假,数字0和nil不支持 字符串1234567891011121314151617181920212223242526272829// 字符串func test3() &#123;\t// 1. 直接使用\tname := &quot;name&quot;\t// 2. 需要换行时候\tusage := `./a.out ./help ./play `\tfmt.Println(name, usage)\t// 3.长度和访问 没有length方法 有自由函数 len()\tl := len(name)\tfmt.Println(l)\t// 4.格式化输出\tfor i := 0; i &lt; len(name); i++ &#123; fmt.Printf(&quot;i:%d,v%c &quot;, i, name[i])\t&#125;\t// 5.字符串拼接\ti, j := &quot;libai&quot;, &quot;hanxin&quot;\tfmt.Println(&quot;i+j:&quot;, i+j)\t// 6.字符串比较\tfmt.Println(&quot;i&gt;j:&quot;, i &gt; j)&#125; 数组+ 切片数组1234567891011121314151617181920212223242526272829303132// 数组func test04() &#123;\t// 1.直接使用\tvar nums = [10]int&#123;1, 2, 3&#125;\tnum := [10]int&#123;1, 2, 3&#125;\tfmt.Println(nums, num)\t// 2. 不定长数组 使用make处理\t// 换种说法 为slice\tnames := []string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;安徽&quot;, &quot;四川&quot;&#125;\tfor k, v := range names &#123; fmt.Println(k, v)\t&#125;\t// 2.1 数组追加\t// 注意: 不仅是有长度的概念 也是有容量的概念\t// 会根据使用情况 + 2*现在长度内存\tnames1 := append(names, &quot;西安&quot;)\tnames1 = append(names1, &quot;西藏&quot;)\tfmt.Println(names, len(names), cap(names), &quot; &quot;, names1, len(names1), cap(names1))\t// 遍历处理方式\tfor i := 0; i &lt; len(nums); i++ &#123; fmt.Print(i, nums[i], &quot;\\t&quot;)\t&#125;\tfmt.Println()\t// 注意:修改v不会概念nums的值 nums[i]修改才会更改的!\t// 对于k,v只会存储一次 不断的进行重复赋值\tfor k, v := range nums &#123; fmt.Print(k, v, &quot;\\t&quot;)\t&#125;\t// 注意:如果想要忽略某一个值 可以用 _ 来占位忽略&#125; 切片123456789101112131415161718192021222324252627282930// 切片func test05() &#123;\tnames := [7]string&#123;&quot;yasuo&quot;, &quot;libai&quot;, &quot;hanxin&quot;, &quot;zhangfei&quot;, &quot;liubei&quot;, &quot;liubei&quot;&#125;\tnames1 := [3]string&#123;&#125;\tnames1[0] = names[0]\tnames1[1] = names[1]\tnames1[2] = names[2]\tfmt.Println(names1)\t// 切片选择就跟python用法差不多一致\t// 但只是浅拷贝\tnames2 := names[0:3]\tnames2[0] = &quot;wuzetian&quot;\tfmt.Println(names2, names)\t// 必须数据污染 可以进行 copy\tarr := make([]string, len(names))\tcopy(arr, names[:])\tfmt.Println(&quot;copy后的arr&quot;, arr)\t// 可以对于字符串进行切片截取: 取字符串的子串\the := &quot;hello world&quot;\tfmt.Println(&quot;sub&quot;, he[5:8])\t// 创建空切片 可以指定一下容量\tls := make([]int, 0, 20)\tfmt.Println(ls, len(ls), cap(ls))&#125; 字典123456789101112131415161718192021222324252627282930313233// 字典func test06() &#123;\t// 存储的是 key:value的映射关系\t// 1.基础使用\t// 需要分配内存 不然会出现\t// panic: assignment to entry in nil map\tvar idNames map[int]string\t// 2. 分配空间 可以分配长度\tidNames = make(map[int]string)\t// 3.可以直接 赋值推导\t// idNames := make(map[int]string)\tidNames[0] = &quot;yasuo&quot;\tidNames[1] = &quot;hanxin&quot;\t// 4.遍历map\tfor k, v := range idNames &#123; fmt.Println(k, v)\t&#125;\t// 判断key存在于map 不存在的话 会返回一个nil\t// 可以借助 第二个参数接受状态\tname3, err := idNames[3]\tfmt.Println(name3, err)\t// 5.删除数值\t// 通过自由函数 delete删除制定的key\tfmt.Println(idNames)\tdelete(idNames, 1)\tdelete(idNames, 100) // 删除不存在的不会报错\tfmt.Println(idNames)&#125; 函数1234567891011121314151617181920// 函数返回值 在参数列表之后// 如果有多个返回值 需要使用括号 进行包裹// 多个参数使用 , 分割func test(a int, b int, c string) (int, string, bool) &#123;\treturn a * b, c, true&#125;// 类型相同的话 可以连着一起操作// 当返回值 有名字的时候 可以直接简写returnfunc test1(a, b int, c string) (res int, str string, bl bool) &#123;\tres = a * b\tstr = c\tbl = true\treturn&#125;// 当返回值 只有一个参数 并且没有名字 不需要加圆括号func test2() int &#123;\treturn 10&#125; 内存逃逸12345678910func testptr() *string &#123;\tname := &quot;yasuo&quot;\tp0 := &amp;name\tfmt.Println(&quot;*po&quot;, *p0)\tcity := &quot;xicdan&quot;\tptr := &amp;city\treturn ptr&#125; 查看方法1go build -gcflags=&quot;-m -m -l&quot; 内存逃逸.go &gt;1.txt 2&gt;&amp;1 相关笔记[Go] 详解内存逃逸 - 掘金 import1234567891011121314151617181920// 如果函数是想被外部访问时候 函数开头要大写 相当于public// 内部是完全可以使用的package mainimport (\t&quot;awesomeProject/src/add&quot;\t//&quot;awesomeProject/src/sub&quot; // 常规导入模式\t//SUB &quot;awesomeProject/src/sub&quot; //类似于重命名\t. &quot;awesomeProject/src/sub&quot; //导入所有包\t&quot;fmt&quot;)func main() &#123;\tres := Sub(20, 10)\tfmt.Println(&quot;res:&quot;, res)\tret := add.Add(20, 20)\tfmt.Println(&quot;ret:&quot;, ret)&#125; 12345package subfunc Sub(a, b int) int &#123;\treturn a - b&#125; 12345package addfunc Add(a, b int) int &#123;\treturn a + b&#125; 目录形式1234567文件夹 PATH 列表卷序列号为 4829-01C8C:.├─.idea└─src ├─add └─sub GOLANG导入自己写的 包/函数_go引入自己的包_江枫霜的博客-CSDN博客 switch + os123456789101112131415161718192021222324252627282930package mainimport (\t&quot;fmt&quot;\t&quot;os&quot;)func main() &#123;\t// 命令行输入\t// c:argc,**argv\t// go:os.Args --&gt;build一下 命令行执行\tcmds := os.Args\t//for k, v := range cmds &#123;\t//\tfmt.Println(&quot;key&quot;, k, &quot;value&quot;, v, &quot;len&quot;, len(cmds))\t//&#125;\tif len(cmds) &lt; 2 &#123; fmt.Println(&quot;please input the arguments&quot;) return\t&#125;\tswitch cmds[1] &#123;\tcase &quot;hello&quot;: fmt.Println(&quot;hello world&quot;) fallthrough // 向下穿透\tcase &quot;world&quot;: fmt.Println(&quot;world hello&quot;)\tdefault: fmt.Println(&quot;hello yasuo&quot;)\t&#125;&#125; 条件控制语句12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123;\t// 标签 label1\t// goto label1 下一次进入循环时候 i不会保存之前的状态 重新从0开始\t// break label1 直接跳出当前循环\t// continue label1 下一下进入循环时候 会记录之前的状态label:\tfor i := 0; i &lt; 5; i++ &#123; for j := 0; j &lt; 5; j++ &#123; if j == 3 &#123; //goto label //continue label break label &#125; fmt.Println(&quot;i:&quot;, i, &quot;j:&quot;, j) &#125;\t&#125;\tfmt.Println(&quot;over&quot;)&#125; 枚举1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;// 模拟表示一周const ( Monday = iota Tuesday Wendesday Thursday Friday Saturday Sunday is_7, not_7 = iota, iota)func main() &#123; // go语言没有枚举类型 可以使用const + iota(常量累加器)模拟实现 // 每换行一次+1 (同一行的iota的数值都是一样的 // 不赋值的话 默认与上一行表达式一致 // 每一个iota是独立的 遇到const iota会重新清零 // 很多定义时候 //var num int //var name string //var flag bool // 使用变量组来统一定义 //var( // num int // name string // flag bool //) fmt.Println(Monday, Tuesday, Wendesday, Thursday, Friday, Saturday, Sunday) fmt.Println(is_7, not_7)&#125; 结构体12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;// c语言 重名 typedef int myInttype myInt int// Person go 语言结构体 type + structtype Person struct &#123; name string age int gender string score float64&#125;func main() &#123; var i, j myInt i, j = 10, 20 fmt.Println(&quot;i+j:&quot;, i+j) // 完全赋值的话 字段名可以不写 yasuo := Person&#123;&quot;yasuo&quot;, 18, &quot;male&quot;, 61&#125; //yasuo := Person&#123; // name: &quot;yasuo&quot;, // age: 18, // gender: &quot;male&quot;, // score: 61, //&#125; // 打印输出方式 fmt.Println(yasuo) ptr1 := &amp;yasuo fmt.Println((*ptr1).name, (*ptr1).age, (*ptr1).gender, (*ptr1).score) fmt.Println(yasuo.name, yasuo.age, yasuo.gender, yasuo.score) // 如果不完全赋值的话 必须指定变量名字 yongen := Person&#123; name: &quot;yongen&quot;, age: 64, &#125; //yongen := Person&#123;&quot;yongen&quot;, 64&#125; // 会报错 fmt.Println(yongen)&#125; init初始化123456789101112131415161718package subimport &quot;fmt&quot;// 1. init初始化函数 没有参数 没有返回值// 2. 一个包含多个init时 调用顺序不确定// 3. init函数是不允许用户显示调用的// 4. 有的时候引用一个包 可能只想使用这个包的 init函数的话 (例如mysql的初始化)// 不想使用其他函数 为了防止编译器报错 可以使用_来处理func init() &#123;\tfmt.Println(&quot;this is init() in package sub&quot;)&#125;func init() &#123;\tfmt.Println(&quot;this is second init() in package sub&quot;)&#125;func Sub(a, b int) int &#123;\treturn a - b&#125; 12345678910package mainimport ( _ &quot;init/sub&quot; // 不想使用其他函数 只想使用init 为了防止编译器报错 可以使用_来处理)func main() &#123; //res := sub.Sub(20, 10) //fmt.Println(&quot;sub.Sub(20,10)&quot;, res)&#125; defer123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;os&quot;)func readFile(filename string) &#123; fl, err := os.Open(filename) // 这样来写用到了 defer //defer fl.Close() // 也可以使用 匿名函数关闭文件 defer func() &#123; fmt.Println(&quot;will close file&quot;) _ = fl.Close() &#125;() if err != nil &#123; fmt.Println(&quot;file to open file:&quot;, filename) return &#125; buf := make([]byte, 1024) n, _ := fl.Read(buf) fmt.Println(&quot;len:&quot;, n, &quot;info:&quot;, string(buf)) defer fmt.Println(&quot;next defer statement&quot;) defer fmt.Println(&quot;last defer statement&quot;)&#125;func main() &#123; // 1. defer 延迟 关键字 用来修饰关键字 函数 在退出时候 一定会执行 // 2. 一般用于资源清理 // 3. 解锁和关闭文件 // 4. 在同一个函数中 多次调用defer 执行时 类似于stack // 多次defer语句 最后写的defer 先执行 stack特征 filename := &quot;base_go1/defer/test.txt&quot; readFile(filename)&#125;","tags":["计算机","编程语言"],"categories":["go","语言基础"]},{"title":"螺旋数组","path":"/2023/01/26/螺旋数组/","content":"螺旋矩阵 | 笔记整理! 破解模板 | 优化方位进行模拟 过于漫长! 1234567891011121314151617181920212223242526# 向左移动i,j=t,lwhile j&lt;=r and head: ls[i][j]=head.val head=head.next j+=1t+=1i,j=t,r# 向下走while i&lt;=d and head: ls[i][j]=head.val head=head.next i+=1r-=1i,j=d,rwhile j&gt;=l and head: ls[i][j]=head.val head=head.next j-=1d-=1i,j=d,lwhile i&gt;=t and head: ls[i][j]=head.val head=head.next i-=1l+=1 优化 | 坐标测试1234567891011121314ans=[[-1]*n for _ in range(m)]# 模拟右下左上d=[[0,1],[1,0],[0,-1],[-1,0]]idx=0cur=[0,0]while head: l,r=cur ans[l][r]=head.val i,j=d[idx] if not 0&lt;=l+i&lt;m or not 0&lt;=r+j&lt;n or ans[l+i][r+j]!=-1: idx=(idx+1)%4 i,j=d[idx] cur=[l+i,r+j] head=head.next 同类习题54.螺旋数组123456789101112131415161718192021class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: m,n=len(matrix),len(matrix[0]) ls=[(0,1),(1,0),(0,-1),(-1,0)] sz=m*n vis=[[1]*n for _ in range(m)] ans=[0]*sz cnt=[0,0] idx=0 ls_id=0 while idx&lt;sz: l,r=cnt ans[idx]=matrix[l][r] vis[l][r]=0 i,j=ls[ls_id] if not 0&lt;=l+i&lt;m or not 0&lt;=r+j&lt;n or vis[l+i][r+j]==0: ls_id=(ls_id+1)%4 i,j=ls[ls_id] cnt=[l+i,r+j] idx+=1 return ans 59.螺旋矩阵21234567891011121314151617181920class Solution: def generateMatrix(self, n: int) -&gt; List[List[int]]: ls=[(0,1),(1,0),(0,-1),(-1,0)] sz=n*n vis=[[1]*n for _ in range(n)] ans=[[1]*n for _ in range(n)] cnt=[0,0] idx=0 ls_id=0 while idx&lt;sz: l,r=cnt ans[l][r]=idx+1 vis[l][r]=0 i,j=ls[ls_id] if not 0&lt;=l+i&lt;n or not 0&lt;=r+j&lt;n or vis[l+i][r+j]==0: ls_id=(ls_id+1)%4 i,j=ls[ls_id] cnt=[l+i,r+j] idx+=1 return ans 885.螺旋矩阵3 思路有所参考 12345678910111213141516171819class Solution: def spiralMatrixIII(self, rows: int, cols: int, rs: int, cs: int) -&gt; List[List[int]]: d=[[0,1],[1,0],[0,-1],[-1,0]] idx=0 a,b=rs,cs ans=[[a,b]] step=0 while len(ans)&lt;rows*cols: i,j=d[idx] step+=1 for i in range(2): for j in range(step): l,r=d[idx] a+=l b+=r if 0&lt;=a&lt;rows and 0&lt;=b&lt;cols: ans.append([a,b]) idx=(idx+1)%4 return ans 2326.螺旋矩阵41234567891011121314151617class Solution: def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -&gt; List[List[int]]: ans=[[-1]*n for _ in range(m)] # 模拟右下左上 d=[[0,1],[1,0],[0,-1],[-1,0]] idx=0 cur=[0,0] while head: l,r=cur ans[l][r]=head.val i,j=d[idx] if not 0&lt;=l+i&lt;m or not 0&lt;=r+j&lt;n or ans[l+i][r+j]!=-1: idx=(idx+1)%4 i,j=d[idx] cur=[l+i,r+j] head=head.next return ans","tags":["算法学习"],"categories":["算法笔记","有趣的题"]},{"title":"字符串匹配笔记 |  笔记整理!","path":"/2023/01/18/字符串匹配/","content":"字符串匹配笔记 | 笔记整理! 字符串匹配问题总结前置信息 | 初始化 | 传入信息123456789def __init__(self,strs,target) -&gt; None: self.s=strs self.t=target self.m=len(self.s) self.n=len(self.t) self.nxt=[0]*(self.n+1) self.nxtval=[0]*(self.n+1) 朴素匹配 | 逐个对比123456789101112131415def plain_match(self): ans=-1 for i in range(self.m-self.n+1): k=i flag=1 for j in range(self.n): if self.s[k]!=self.t[j]: flag=0 break else: k+=1 if flag: ans=i break return ans 字符串哈希 | 存在理论上失败的可能12345678910111213141516171819202122232425262728293031323334353637383940414243class BKDRHash(): def __init__(self,strs,target) -&gt; None: self.s=strs self.t=target self.m=len(self.s) self.n=len(self.t) self.pp=131 self.pre=[0]*self.m self.pattern_val=-1 self.ans=-1 # 求取匹配串的哈希数值 def get_v(self): for k,v in enumerate(self.t): cur=ord(v)-ord(&#x27;a&#x27;)+1 if k: self.pattern_val=self.pattern_val*self.pp+cur else: self.pattern_val=cur # 利用前缀哈希和 求取 def get_ans(self): for k,v in enumerate(self.s): cur=ord(v)-ord(&#x27;a&#x27;)+1 if k: self.pre[k]=self.pre[k-1]*self.pp+cur else: self.pre[k]=cur if k==self.n-1: if self.pre[k]==self.pattern_val: self.ans=0 break if k&gt;self.n-1: val=self.pre[k]-self.pre[k-self.n]*pow(self.pp,self.n) if self.pattern_val==val: self.ans=k+1-self.n break def run(self): self.get_v() self.get_ans() return self.ans kmp算法 | 求next nextval数组逻辑1234567891011121314151617181920212223242526272829303132333435363738def get_next(self): j=0 for i in range(1,self.n): while j and self.t[i]!=self.t[j]: j=self.nxt[j] if self.t[i]==self.t[j]: j+=1 self.nxt[i+1]=jdef get_nextval(self): j=0 for i in range(1,self.n): while j and self.t[i]!=self.t[j]: j=self.nxtval[j] if self.t[i]==self.t[j]: j+=1 self.nxtval[i+1]=j # 纯直接丑陋思路 | 没想到更好的 不过这样也不错! if self.t[self.nxtval[i]]==self.t[i]: self.nxtval[i]=self.nxtval[self.nxtval[i]]def get_key(self,nxt): ans=-1 j=0 for i in range(self.m): while j and self.s[i]!=self.t[j]: j=nxt[j] if self.s[i]==self.t[j]: j+=1 if j==self.n: ans=i+1-self.n break return ansdef get_key_bool(self,nxt): return self.get_key(nxt)!=-1 拓展kmp(Z)算法 | 不同写法0-base1234567891011121314151617# 拓展kmp算法! |def extend_kmp_1_base(self,s): l,r=1,0 s=&#x27;0&#x27;+s n=len(s) z=[0]*(n) for i in range(2,n): if i&gt;r: z[i]=0 else: k=i-l+1 z[i]=min(z[k],r-i+1) while i+z[i]&lt;n and s[i+z[i]]==s[1+z[i]]: z[i]+=1 if i+z[i]-1&gt;r: l,r=i,i+z[i]-1 return z 1-Base12345678910111213def extend_kmp_0_base(self,s): l,r=0,-1 n=len(s) z=[0]*n for i in range(1,n): if i&lt;=r: k=i-l+1 z[i]=min(z[k],r-i+1) while i+z[i]&lt;n and s[i+z[i]]==s[0+z[i]]: z[i]+=1 if i+z[i]-1&gt;r: l,r=i,i+z[i]-1 return z 完整代码 | 哈希字符串 + Kmp哈希字符串123456789101112131415161718192021222324252627282930313233343536373839404142class Kmp(): def __init__(self,strs,target) -&gt; None: self.s=strs self.t=target self.m=len(self.s) self.n=len(self.t) self.pp=131 self.pre=[0]*self.m self.pattern_val=-1 self.ans=-1 # 求取匹配串的哈希数值 def get_v(self): for k,v in enumerate(self.t): cur=ord(v)-ord(&#x27;a&#x27;)+1 if k: self.pattern_val=self.pattern_val*self.pp+cur else: self.pattern_val=cur # 利用前缀哈希和 求取 def get_ans(self): for k,v in enumerate(self.s): cur=ord(v)-ord(&#x27;a&#x27;)+1 if k: self.pre[k]=self.pre[k-1]*self.pp+cur else: self.pre[k]=cur if k==self.n-1: if self.pre[k]==self.pattern_val: self.ans=0 break if k&gt;self.n-1: val=self.pre[k]-self.pre[k-self.n]*pow(self.pp,self.n) if self.pattern_val==val: self.ans=k+1-self.n break def run(self): self.get_v() return self.get_ans() Kmp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class Kmp(): def __init__(self,strs,target) -&gt; None: self.s=strs self.t=target self.m=len(self.s) self.n=len(self.t) self.nxt=[0]*(self.n+1) self.nxtval=[0]*(self.n+1) def plain_match(self): ans=-1 for i in range(self.m-self.n+1): k=i flag=1 for j in range(self.n): if self.s[k]!=self.t[j]: flag=0 break else: k+=1 if flag: ans=i break return ans def get_next(self): j=0 for i in range(1,self.n): while j and self.t[i]!=self.t[j]: j=self.nxt[j] if self.t[i]==self.t[j]: j+=1 self.nxt[i+1]=j def get_nextval(self): j=0 for i in range(1,self.n): while j and self.t[i]!=self.t[j]: j=self.nxtval[j] if self.t[i]==self.t[j]: j+=1 self.nxtval[i+1]=j # 纯直接丑陋思路 | 没想到更好的 不过这样也不错! if self.t[self.nxtval[i]]==self.t[i]: self.nxtval[i]=self.nxtval[self.nxtval[i]] def get_key(self,nxt): ans=-1 j=0 for i in range(self.m): while j and self.s[i]!=self.t[j]: j=nxt[j] if self.s[i]==self.t[j]: j+=1 if j==self.n: ans=i+1-self.n break return ans def get_key_count(self,nxt): ans=j=0 for i in range(self.m): while j and self.s[i]!=self.t[j]: j=nxt[j] if self.s[i]==self.t[j]: j+=1 if j==self.n: j=nxt[j] ans+=1 return ans def get_key_bool(self,nxt): return self.get_key(nxt)!=-1 # 拓展kmp算法! | def extend_kmp_1_base(self,s): l,r=1,0 s=&#x27;0&#x27;+s n=len(s) z=[0]*(n) for i in range(2,n): if i&gt;r: z[i]=0 else: k=i-l+1 z[i]=min(z[k],r-i+1) while i+z[i]&lt;n and s[i+z[i]]==s[1+z[i]]: z[i]+=1 if i+z[i]-1&gt;r: l,r=i,i+z[i]-1 return z def extend_kmp_0_base(self,s): l,r=0,-1 n=len(s) z=[0]*n for i in range(1,n): if i&lt;=r: k=i-l+1 z[i]=min(z[k],r-i+1) while i+z[i]&lt;n and s[i+z[i]]==s[0+z[i]]: z[i]+=1 if i+z[i]-1&gt;r: l,r=i,i+z[i]-1 return z","categories":["算法笔记","数据结构","字符串","字符串匹配"]},{"title":"整数除法 | 笔记整理!","path":"/2023/01/16/整数除法/","content":"整数除法 | 笔记整理! 小知识点 | 总结快速幂思路优化 加法优化 12345678def quick_mul(x,y): ans=0 while y: if y&amp;1: ans+=x x+=x y&gt;&gt;=1 return ans 幂乘优化 12345678def quick_pow(x,y): ans=0 while y: if y&amp;1: ans+=x x&lt;&lt;=1 y&gt;&gt;=1 return ans 整数二分 | 向下取整 -&gt; 左闭右开区间思路 寻找后继 | 向上取整 12345678910def binary_search_right(nums,n,val): # 左闭右开区间 l,r=0,n while l&lt;r: mid=l+r&gt;&gt;1 if nums[mid]&gt;=val: r=mid else: l=mid+1 return l 寻找前驱 | 向下取整 12345678910def binary_search_left(nums,n,val): # 左闭右开区间 l,r=0,n while l&lt;r: mid=(l+r+1)&gt;&gt;1 if nums[mid]&lt;=val: l=mid else: r=mid-1 return l 特判 + 符号 | 二分 + 加法123456789101112131415161718192021222324252627282930313233class Solution: def divide(self, a: int, b: int) -&gt; int: # 快速幂优化 def quick_mul(x,y): ans=0 while y: if y&amp;1: ans+=x x+=x y&gt;&gt;=1 return ans # 先进行特判 INT_MIN,INT_MAX=-2**31,2**31-1 if a==INT_MIN: if b==1:return a if b==-1:return INT_MAX # 二分实现 经典的左闭右开区间 tag=1 if a*b&gt;=0 else -1 if a&lt;0:a=-a if b&lt;0:b=-b def binary_search_left(l,r): while l&lt;r: mid=l+r+1&gt;&gt;1 if quick_mul(mid,b)&lt;=a: l=mid else: r=mid-1 return l ans=binary_search_left(0,a) return ans*tag 模拟实现 | 但不符合题目要求123456789101112131415161718192021class Solution: def divide(self,a: int, b: int) -&gt; int: INT_MIN,INT_MAX=-2**31,2**31-1 if a==INT_MIN: if b==1:return a if b==-1:return INT_MAX t=1 if a*b&gt;=0 else -1 m,n=str(abs(a)),str(abs(b)) flag=[&#x27;0&#x27;]*len(m) def helper(x,y): r=0 for i in range(len(m)): r=r*10+ord(x[i])-ord(&#x27;0&#x27;) if r&lt;y: flag[i]=&#x27;0&#x27; else: flag[i]=str(r//y) r%=y helper(m,abs(b)) return t*int(&#x27;&#x27;.join(flag))","categories":["算法笔记","基础算法"]},{"title":"回文串 | 笔记整理!","path":"/2023/01/16/回文串判断/","content":"回文串 | 笔记整理! 回文串判断暴力 | 中心扩散法1234567891011121314151617class Solution: def longestPalindrome(self, s: str) -&gt; str: n=len(s) def helper(i,j): while i&gt;=0 and j&lt;n and s[i]==s[j]: i-=1 j+=1 return i+1,j-1 #回复到原本状态 st,e=0,0 for i in range(0,n): a,b=helper(i,i) if b-a&gt;e-st: st,e=a,b c,d=helper(i,i+1) if d-c&gt;e-st: st,e=c,d return s[st:e+1] 优化 | 动态规划思路 参考《算法笔记》思路 123456789101112131415161718192021222324class Solution: def longestPalindrome(self, s: str) -&gt; str: n=len(s) dp=[[0 for _ in range(n)] for _ in range(n)] ans=1 idx=0 for i in range(n): dp[i][i]=1 #本身就是回文串 if i+1&lt;n and s[i]==s[i+1]: dp[i][i+1]=1 #两个最基本的连续 if ans&lt;2: ans=2 idx=i for k in range(3,n+1):# 从3~n进行遍历 如果这个字符串整个都是 回文串的话 for i in range(n): j=k+i-1 if j&gt;=n:break if s[i]==s[j] and dp[i+1][j-1]==1: dp[i][j]=1 if ans&lt;k: ans=k idx=i return s[idx:idx+ans] 优化 | $manacher$算法 比较有难度,参考罗勇军老师的《算法竞赛》一书 12345678910111213141516171819202122232425class Solution: def longestPalindrome(self, s: str) -&gt; str: # manacher马拉车 ls=&#x27;#&#x27;+&#x27;#&#x27;.join(list(s))+&#x27;#&#x27; n=len(ls) p=[1]*n #改进一下 --&gt;初始化为1 即可 r,c=0,0 ans,idx=0,0 for i in range(1,n): if i&lt;r: p[i]=min(p[2*c-i],c+p[c]-i) # 暴力中心扩散 while i+p[i]&lt;n and i-p[i]&gt;=0 and ls[i+p[i]]==ls[i-p[i]]:p[i]+=1 # 更新回文中心即可 if i+p[i]&gt;r: r=i+p[i] c=i # 用作数据统计分析 if p[i]&gt;ans: ans,idx=p[i],i ans-=1 st=(idx-ans)//2 return s[st:st+ans]","categories":["算法笔记","字符串"]},{"title":"字典树 | 笔记整理!","path":"/2023/01/16/前缀树/","content":"字典树 | 笔记整理! 字典树实现 | 数组 + 字典(哈希表)208.实现 Trie (前缀树) 数组存储1234567891011121314151617181920212223242526272829class Trie(): def __init__(self) -&gt; None: self.d=[0]*26 self.flag=False def insert(self,words): node=self for i in words: i=ord(i)-ord(&#x27;a&#x27;) if node.d[i]==0: node.d[i]=Trie() node=node.d[i] node.flag=True def search(self,words): node=self.search_prefix(words) return node!=None and node.flag def search_prefix(self,words): node=self for i in words: i=ord(i)-ord(&#x27;a&#x27;) if node.d[i]==0: return None node=node.d[i] return node def startsWith(self,words): return self.search_prefix(words)!=None 哈希表(字典)存储1234567891011121314151617181920212223242526272829class Trie: def __init__(self): self.d=defaultdict(int) self.tag=False def insert(self, word: str) -&gt; None: node=self for i in word: v=ord(i)-ord(&#x27;a&#x27;) if not node.d[v]: node.d[v]=Trie() node=node.d[v] node.tag=True def search_prefix(self, word: str) -&gt; bool: node=self for i in word: v=ord(i)-ord(&#x27;a&#x27;) if not node.d[v]: return None node=node.d[v] return node def search(self,word): node=self.search_prefix(word) return node is not None and node.tag def startsWith(self, prefix: str) -&gt; bool: return self.search_prefix(prefix) is not None 应用判断前缀和14. 最长公共前缀 暴力 | 强行操作即可123456789101112class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: def helper(x,y): i=0 while i&lt;len(x) and i&lt;len(y) and x[i]==y[i]: i+=1 return x[:i] n=len(strs) ans=strs[0] for i in range(1,n): ans=helper(ans,strs[i]) return ans 分治 | 参考归并排序 (合并k个链表)12345678910111213141516class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: ### 分治思想 def helper(l,r): if l&gt;=r: return strs[l] mid=l+r&gt;&gt;1 l=helper(l,mid) r=helper(mid+1,r) k=min(len(l),len(r)) for i in range(k): if l[i]!=r[i]: k=i break return l[:k] return helper(0,len(strs)-1) 前缀树 | 存储 字符即可123456789101112131415161718192021222324252627class Trie: def __init__(self): self.d=defaultdict(int) self.tag=False def insert(self, word: str) -&gt; None: node=self for v in word: if not node.d[v]: node.d[v]=Trie() node=node.d[v] node.tag=True def search(self, word: str) -&gt; bool: node=self ans=&#x27;&#x27; for v in word: ### 遇到分治或是到达低端 就判断即可! if len(node.d)&gt;1 or node.tag: return ans if v in node.d: ans+=v node=node.d[v] return ansclass Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: t=Trie() for i in strs:t.insert(i) return t.search(strs[0])","categories":["算法笔记","进阶算法"]},{"path":"/2023/01/13/有趣的题/","content":"好题 | 笔记整理! 链表+ 树(层次遍历) | bfs +dfs | 心得面试题 04.03. 特定深度节点链表 bfs | 借助队列处理 常规处理 1234567891011121314151617class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: q=[tree] ans=[] while q: sz=len(q) pre=x=ListNode() for i in range(sz): node=q[0] del q[0] x.next=ListNode(node.val) x=x.next if node.left:q.append(node.left) if node.right:q.append(node.right) x.next=None ans.append(pre.next) return ans dfs | 先left | 先right 受树层次遍历启发! 先left处理 | 插入节点是在末位 并不是很常见 12345678910111213141516171819# 先left处理时候 插入节点是在链表末位插入class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append(ListNode(root.val)) else: pre=ans[level] # 末位处理|找到链表结尾部分 while pre.next:pre=pre.next pre.next=cur pre=pre.next dfs(root.left,level+1) dfs(root.right,level+1) dfs(tree,0) return ans 可以存储末位部分 略有优化 123456789101112131415class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append([cur,cur]) else: ans[level][-1].next=cur ans[level][-1]=ans[level][-1].next dfs(root.left,level+1) dfs(root.right,level+1) dfs(tree,0) return [k for k,_ in ans] 先right处理 | 直接尾插法即可2326. 螺旋矩阵 IV 比较容易 123456789101112131415class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append(cur) else: cur.next=ans[level] ans[level]=cur dfs(root.right,level+1) dfs(root.left,level+1) dfs(tree,0) return ans 螺旋数组 | 笔记心得暴力破解 | 只能暴力找规律 过于漫长! 123456789101112131415161718192021222324252627282930313233class Solution: def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -&gt; List[List[int]]: ls=[[-1 for _ in range(n)] for _ in range(m)] l,r=0,n-1 t,d=0,m-1 while head: # 向左移动 i,j=t,l while j&lt;=r and head: ls[i][j]=head.val head=head.next j+=1 t+=1 i,j=t,r # 向下走 while i&lt;=d and head: ls[i][j]=head.val head=head.next i+=1 r-=1 i,j=d,r while j&gt;=l and head: ls[i][j]=head.val head=head.next j-=1 d-=1 i,j=d,l while i&gt;=t and head: ls[i][j]=head.val head=head.next i-=1 l+=1 return ls 逻辑优化一下 | 试试看 借鉴大佬 | 确实6 1234567891011121314151617class Solution: def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -&gt; List[List[int]]: ans=[[-1]*n for _ in range(m)] # 模拟右下左上 d=[[0,1],[1,0],[0,-1],[-1,0]] idx=0 cur=[0,0] while head: l,r=cur ans[l][r]=head.val i,j=d[idx] if not 0&lt;=l+i&lt;m or not 0&lt;=r+j&lt;n or ans[l+i][r+j]!=-1: idx=(idx+1)%4 i,j=d[idx] cur=[l+i,r+j] head=head.next return ans","categories":["算法学习","有趣的题"]},{"title":"链表 |  笔记整理!","path":"/2023/01/13/链表/","content":"链表 | 笔记整理! 算法竞赛 | 例题:约瑟夫 算法竞赛例题 | 洛谷 P1996 约瑟夫问题 题目# P1996 约瑟夫问题 求解数组 | 标记 模拟12345678910111213m,n=map(int,input().split())flag=[0]*(m+1)idx=0for i in range(m):\tj=0\twhile j&lt;n: idx+=1 if idx&gt;m:idx=1 if flag[idx]:j-=1 j+=1\tprint(idx,end=&#x27; &#x27;)\tflag[idx]=1 单链表处理1234567891011121314151617181920212223m,n=map(int,input().split())class LinkNode():\tdef __init__(self,val=0,next=None) -&gt; None: self.val=val self.next=nextnode=cur=Nonefor i in range(1,m+1):\tif i==1: cur=node=LinkNode(i)\telse: cur.next=LinkNode(i) cur=cur.nextcur.next=nodehead=prev=nodefor _ in range(m):\tfor _ in range(1,n): prev=head head=head.next\tprint(head.val,end=&#x27; &#x27;)\tprev.next=head.next\thead=prev.next 静态链表处理123456789101112131415m,n=map(int,input().split())node=[0]*(m+1)for i in range(1,m):\tnode[i]=i+1node[m]=1prev=head=1for _ in range(m):\tfor _ in range(1,n): prev=head head=node[head]\tprint(head,end=&#x27; &#x27;)\tnode[prev]=node[head]\thead=node[prev] 力扣刷题 | 部分经典题目 部分总结归纳 dfs做法 | 笔记整理在另一篇面试题 04.03. 特定深度节点链表 123456789101112131415class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append(cur) else: cur.next=ans[level] ans[level]=cur dfs(root.right,level+1) dfs(root.left,level+1) dfs(tree,0) return ans 模拟加减运算链表求和 12345678910111213141516171819class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: def cal_ans(l1,l2): flag=0 head=ans=ListNode() while l1 or l2: x=l1.val if l1 else 0 y=l2.val if l2 else 0 s=x+y+flag flag=s//10 cur=ListNode(s%10) ans.next=cur ans=ans.next if l1:l1=l1.next if l2:l2=l2.next if flag: ans.next=ListNode(1) return head.next return cal_ans(l1,l2) 环路检测 问题 set集合检测 | 环装归纳 环路检测 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def detectCycle(self, head: ListNode) -&gt; ListNode: # 经典做法就是 用set来存储 然后进行检测 # 优化方案--&gt;快慢指针(叫双指针也行) # b是环的起点到相遇的地方(c的开始)--&gt;故相遇之后a==c # 原理推导 a+n(b+c)+b==2(a+b)--&gt;a=(n-1)b+cn #--&gt;a=c+(n-1)(b+c) (b+c是环) fast=slow=head while fast: slow=slow.next if fast.next: fast=fast.next.next else: return None if fast==slow: while head!=slow: head=head.next slow=slow.next return head return None 链表 + 前缀和从链表中删去总和值为零的连续节点 12345678910111213141516171819# 使用dict来存储,第一次遍历会覆盖重复的pre保留为最后一次的class Solution: def removeZeroSumSublists(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: cur=dummpy=ListNode(0,head) pre=0 d=dict() while cur: pre+=cur.val d[pre]=cur cur=cur.next s=0 cur=dummpy while cur: s+=cur.val cur.next=d[s].next cur=cur.next return dummpy.next 经典递归调用 | 树+链表 此处过于精彩! 二叉树中的链表 1234567891011class Solution: def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -&gt; bool: def helper(head,root): if not head:return True if not root:return False if head.val!=root.val: return False return helper(head.next,root.left) or helper(head.next,root.right) # 突破口是 在这里 不断的递归枚举调用! if not root:return False return helper(head,root) or self.isSubPath(head,root.left) or self.isSubPath(head,root.right) 小结 这部分还是比较重要的，如果单纯考链表就比较容易了！","categories":["数据结构","链表"]},{"title":"堆| 笔记整理!","path":"/2023/01/12/堆/","content":"堆| 笔记整理! 思路梳理 | 结构体部分123def __init__(self) -&gt; None: self.heap_list=[0] self.length=0 主体部分是 | 上升和下降上升部分 | 对应的是 插入1234567891011def perc_up(self,i): while i//2&gt;0: # 当前节点是 小于父节点的 if self.heap_list[i]&lt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1def insert(self,k): self.heap_list.append(k) self.length+=1 self.perc_up(self.length) 下降部分 | 对应的是建立 + 删除堆顶元素123456789101112131415161718192021222324252627282930def perc_down(self,i): while i*2&lt;=self.length: idx=self.min_child(i) if self.heap_list[i]&gt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx def min_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&lt;self.heap_list[i*2+1]: return i*2 return i*2+1 def del_min(self): min_val=self.heap_list[1] # self.heap_list[1]=self.heap_list[self.length] # 这样来写也可以id self.heap_list[-1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return min_val def build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1 完整代码 | 关于最大堆+最小堆最大堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class BinaryHeap():\tdef __init__(self): self.heap_list=[0] self.length=0\tdef insert(self,i): self.heap_list.append(i) self.length+=1 self.perc_up(self.length)\tdef perc_up(self,i): while i//2&gt;0: if self.heap_list[i]&gt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1\tdef max_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&gt;self.heap_list[i*2+1]: return i*2 return i*2+1\tdef del_max(self,i): val=self.heap_list[1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return val\tdef perc_down(self,i): while i*2&lt;=self.length: idx=self.max_child(i) if self.heap_list[i]&lt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx\tdef build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1if __name__==&#x27;__main__&#x27;:\tls=[9,5,6,3,2,3,10]\theap=BinaryHeap()\theap.build_heap(ls)\tprint(heap.heap_list) 最小堆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class BinaryHeap(): def __init__(self) -&gt; None: self.heap_list=[0] self.length=0 def perc_up(self,i): while i//2&gt;0: # 当前节点是 小于父节点的 if self.heap_list[i]&lt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1 def insert(self,k): self.heap_list.append(k) self.length+=1 self.perc_up(self.length) def perc_down(self,i): while i*2&lt;=self.length: idx=self.min_child(i) if self.heap_list[i]&gt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx def min_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&lt;self.heap_list[i*2+1]: return i*2 return i*2+1 def del_min(self): min_val=self.heap_list[1] # self.heap_list[1]=self.heap_list[self.length] # 这样来写也可以id self.heap_list[-1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return min_val def build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1if __name__==&#x27;__main__&#x27;: ls=[9,6,5,2,3] heap=BinaryHeap() heap.build_heap(ls) print(heap.heap_list)","categories":["数据结构","树"]},{"title":"排序 |  笔记整理!","path":"/2023/01/12/排序/","content":"排序 | 笔记整理! 快速排序123456789101112131415161718192021222324252627282930import numpy as npdef quick_sort(nums,l,r): if l&gt;=r: return # 稍微进行优化! rand=l+np.random.randint(100)%(r-l+1) nums[l],nums[rand]=nums[rand],nums[l] x=nums[l] i,j=l,r while i&lt;j: while i&lt;j and nums[j]&gt;x:j-=1 if i&lt;j: nums[i]=nums[j] i+=1 while i&lt;j and nums[i]&lt;x:i+=1 if i&lt;j: nums[j]=nums[i] j-=1 nums[i]=x quick_sort(nums,l,i-1) quick_sort(nums,i+1,r)if __name__==&#x27;__main__&#x27;: nums=np.random.randint(100,size=12) print(&quot;生成的数组是:&quot;,nums) quick_sort(nums,0,11) print(&quot;排序后数组是:&quot;,nums) 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npdef merge_sort(nums,l,r): if l&gt;=r: return mid=l+r&gt;&gt;1 # 对于 l~mid 和 mid+1~r 进行分别处理 merge_sort(nums,l,mid) merge_sort(nums,mid+1,r) # 此处已经是 处理之后的 结果.进行归并即可! i,j=l,mid+1 idx=0 while i&lt;=mid and j&lt;=r: if nums[i]&lt;=nums[j]: help_ls[idx]=nums[i] i+=1 else: help_ls[idx]=nums[j] j+=1 idx+=1 while i&lt;=mid: help_ls[idx]=nums[i] i+=1 idx+=1 while j&lt;=r: help_ls[idx]=nums[j] j+=1 idx+=1 # 进行复制即可 for i in range(idx): nums[l+i]=help_ls[i]if __name__==&#x27;__main__&#x27;: n=12 nums=np.random.randint(100,size=n) help_ls=[0]*n # 生成辅助数组 print(&quot;生成的数组是:&quot;,nums) merge_sort(nums,0,11) print(&quot;排序后数组是:&quot;,nums) 计数排序 理解记忆 1234567891011121314151617181920212223242526272829303132import numpy as npdef counting_sort(nums): # 进行计数 for i in nums: help_c[i]+=1 # 输出结果 print(&quot;排序后数组是:&quot;,end=&#x27; &#x27;) for i in range(max_val): for j in range(help_c[i]): #需要重复的次数是 print(i,end=&#x27; &#x27;) # 前缀和 for i in range(1,max_val): help_c[i]+=help_c[i-1] for i in range(n-1,-1,-1): help_r[i]=help_c[nums[i]] help_c[nums[i]]-=1 print(&quot; 出现的次序:&quot;,end=&#x27; &#x27;) for i in range(n): print(help_r[i],end=&#x27; &#x27;)if __name__==&#x27;__main__&#x27;: n=12 max_val=10 nums=np.random.randint(max_val,size=n) help_a=[0]*n # 生成辅助数组 help_c=[0]*n # 生成辅助数组 help_r=[0]*n # 生成辅助数组 print(&quot;生成的数组是:&quot;,nums) counting_sort(nums) 基数排序1234567891011121314151617181920212223242526272829303132import numpy as npdef counting_sort(): help_c=[0]*10 # 生成辅助数组 # 进行计数即可 for i in help_v: help_c[i]+=1 # 前缀和 for i in range(1,10): help_c[i]+=help_c[i-1] # 从后开始 这是用help_s用来标记位次顺序 for i in range(n-1,-1,-1): help_r[help_s[i]]=help_c[help_v[help_s[i]]] help_c[help_v[help_s[i]]]-=1 # 记录这次之后的位次顺序 因为是从0开始的 位次是1 for i in range(n): help_s[help_r[i]-1]=iif __name__==&#x27;__main__&#x27;: n=12 max_val=100 nums=np.random.randint(max_val,size=n) help_s=list(range(n)) help_r=[0]*n # 生成辅助数组 help_v=[0]*n # 生成辅助数 x=1 print(&quot;生成的数组是:&quot;,list(nums)) for i in range(2): for j in range(n): help_v[j]=nums[j]//x%10 counting_sort() x*=10 print(&quot;排序后数组是:&quot;,[nums[help_s[i]] for i in range(n)])","categories":["数据结构","排序"]},{"title":"字符串转换数字 |  笔记整理!","path":"/2023/01/12/字符串/","content":"字符串转换数字 | 笔记整理! 字符串字符串转为数字[]12345678910111213141516# 使用for循环即可! 需要考虑末位class Solution: def areNumbersAscending(self, s: str) -&gt; bool: pre=0 num=0 for i in s: if &#x27;0&#x27;&lt;=i&lt;=&#x27;9&#x27;: num=num*10+ord(i)-ord(&#x27;0&#x27;) else: if num&gt;=1: if pre&gt;=num:return False pre=num num=0 # 需要考虑到末位 if num and pre&gt;=num:return False return True []1234567891011121314151617181920# 使用while遍历即可class Solution: def areNumbersAscending(self, s: str) -&gt; bool: pre=0 n=len(s) i=0 num=0 while i&lt;n: if s[i].isdigit(): while i&lt;n and s[i].isdigit(): num=num*10+ord(s[i])-ord(&#x27;0&#x27;) i+=1 if not pre: pre=num elif pre&gt;=num:return False else:pre=num print(num) num=0 i+=1 return True","categories":["算法笔记","字符串"]},{"title":"解析树| 笔记整理!","path":"/2023/01/12/解析树/","content":"解析树| 笔记整理! 笔记心得 参考Python数据结构(外) 结构体部分 | 插入部分是必要的1234567891011121314151617181920class TreeNode: def __init__(self, val=&#x27;&#x27;, left=None, right=None): self.val = val self.left = left self.right = right def insert_left(self,val=&#x27;&#x27;): t=TreeNode(val) if not self.left: self.left=t else: t.left=self.left self.left=t def insert_right(self,val=&#x27;&#x27;): t=TreeNode(val) if not self.right: self.right=t else: t.right=self.right self.right=t 进行建树 | 合理利用栈即可1234567891011121314151617181920212223def build_parse_tree(s): ls=list(s) root=TreeNode() stk=[root] cur=root for i in ls: if i==&#x27;(&#x27;: cur.insert_left() #进行占位 stk.append(cur) cur=cur.left elif i not in &#x27;+-*/)&#x27;: cur.val=int(i) cur=stk.pop() elif i in &#x27;+-*/&#x27;: cur.val=i cur.insert_right() stk.append(cur) cur=cur.right elif i==&#x27;)&#x27;: cur=stk.pop() else: raise ValueError(&quot;当前输入不合法!&quot;) return root 计算解析树 | 递归处理12345678910111213def get_ans(root): map=&#123; &#x27;+&#x27;:lambda x,y:x+y, &#x27;-&#x27;:lambda x,y:x-y, &#x27;*&#x27;:lambda x,y:x*y, &#x27;/&#x27;:lambda x,y:x/y, &#125; l=root.left r=root.right if l and r: return map[root.val](get_ans(l),get_ans(r)) else: return root.val 遍历输出 | 利用中序遍历 这部分不自信 错了滴滴我 原书思路12345def print_exp1(root): ans=&#x27;&#x27; if root: ans=&#x27;(&#x27;+print_exp(root.left)+str(root.val)+print_exp(root.right)+&#x27;)&#x27; return ans 优化12345678def print_exp2(root): ans=&#x27;&#x27; if root: if root.left and root.right: ans=&#x27;(&#x27;+print_exp(root.left)+str(root.val)+print_exp(root.right)+&#x27;)&#x27; else: ans=print_exp(root.left)+str(root.val)+print_exp(root.right) return ans 感觉还可以优化一下 | 根据优先级12345678910111213141516def helper(root,flag): map=&#123; &#x27;+&#x27;:1,&#x27;-&#x27;:1, &#x27;*&#x27;:2,&#x27;/&#x27;:2 &#125; ans=&#x27;&#x27; if root: ans=helper(root.left,flag)+str(root.val)+helper(root.right,flag) if root.left and root.right: if root.val in map and map[root.val]&gt;=flag: flag=map[root.val] ans=helper(root.left,flag)+str(root.val)+helper(root.right,flag) else: ans=&#x27;(&#x27;+ans+&#x27;)&#x27; return ans 感觉不是很难 | 2023.1.12 算法之路 不断精进!","tags":["算法笔记"],"categories":["数据结构","树"]},{"title":"关于","path":"/about/index.html","content":"夏桑就读于克莱登大学，职业写Bug，擅长摸鱼。实验室下班钟点工，精通各种编程技能，如手撕HelloWorld。力扣周赛坐牢冠军，专业认证CV工程师。前面的话都是编的，但说真的，很抱歉，怪遗憾的挺想你的。O(∩_∩)O哈哈~"},{"path":"/notes/index.html","content":"笔记部分"},{"path":"/more/rss/index.html","content":""}]