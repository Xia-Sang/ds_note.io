[{"path":"/2023/01/16/整数除法/","content":"整数除法 | 笔记整理! 小知识点 | 总结快速幂思路优化 加法优化 12345678def quick_mul(x,y): ans=0 while y: if y&amp;1: ans+=x x+=x y&gt;&gt;=1 return ans 幂乘优化 12345678def quick_pow(x,y): ans=0 while y: if y&amp;1: ans+=x x&lt;&lt;=1 y&gt;&gt;=1 return ans 整数二分 | 向下取整 -&gt; 左闭右开区间思路 寻找后继 | 向上取整 12345678910def binary_search_right(nums,n,val): # 左闭右开区间 l,r=0,n while l&lt;r: mid=l+r&gt;&gt;1 if nums[mid]&gt;=val: r=mid else: l=mid+1 return l 寻找前驱 | 向下取整 12345678910def binary_search_left(nums,n,val): # 左闭右开区间 l,r=0,n while l&lt;r: mid=(l+r+1)&gt;&gt;1 if nums[mid]&lt;=val: l=mid else: r=mid-1 return l 特判 + 符号 | 二分 + 加法123456789101112131415161718192021222324252627282930313233class Solution: def divide(self, a: int, b: int) -&gt; int: # 快速幂优化 def quick_mul(x,y): ans=0 while y: if y&amp;1: ans+=x x+=x y&gt;&gt;=1 return ans # 先进行特判 INT_MIN,INT_MAX=-2**31,2**31-1 if a==INT_MIN: if b==1:return a if b==-1:return INT_MAX # 二分实现 经典的左闭右开区间 tag=1 if a*b&gt;=0 else -1 if a&lt;0:a=-a if b&lt;0:b=-b def binary_search_left(l,r): while l&lt;r: mid=l+r+1&gt;&gt;1 if quick_mul(mid,b)&lt;=a: l=mid else: r=mid-1 return l ans=binary_search_left(0,a) return ans*tag 模拟实现 | 但不符合题目要求123456789101112131415161718192021class Solution: def divide(self,a: int, b: int) -&gt; int: INT_MIN,INT_MAX=-2**31,2**31-1 if a==INT_MIN: if b==1:return a if b==-1:return INT_MAX t=1 if a*b&gt;=0 else -1 m,n=str(abs(a)),str(abs(b)) flag=[&#x27;0&#x27;]*len(m) def helper(x,y): r=0 for i in range(len(m)): r=r*10+ord(x[i])-ord(&#x27;0&#x27;) if r&lt;y: flag[i]=&#x27;0&#x27; else: flag[i]=str(r//y) r%=y helper(m,abs(b)) return t*int(&#x27;&#x27;.join(flag))","categories":["算法学习","整数除法"]},{"path":"/2023/01/16/回文串判断/","content":"回文串 | 笔记整理! 回文串判断暴力 | 中心扩散法1234567891011121314151617class Solution: def longestPalindrome(self, s: str) -&gt; str: n=len(s) def helper(i,j): while i&gt;=0 and j&lt;n and s[i]==s[j]: i-=1 j+=1 return i+1,j-1 #回复到原本状态 st,e=0,0 for i in range(0,n): a,b=helper(i,i) if b-a&gt;e-st: st,e=a,b c,d=helper(i,i+1) if d-c&gt;e-st: st,e=c,d return s[st:e+1] 优化 | 动态规划思路 参考《算法笔记》思路 123456789101112131415161718192021222324class Solution: def longestPalindrome(self, s: str) -&gt; str: n=len(s) dp=[[0 for _ in range(n)] for _ in range(n)] ans=1 idx=0 for i in range(n): dp[i][i]=1 #本身就是回文串 if i+1&lt;n and s[i]==s[i+1]: dp[i][i+1]=1 #两个最基本的连续 if ans&lt;2: ans=2 idx=i for k in range(3,n+1):# 从3~n进行遍历 如果这个字符串整个都是 回文串的话 for i in range(n): j=k+i-1 if j&gt;=n:break if s[i]==s[j] and dp[i+1][j-1]==1: dp[i][j]=1 if ans&lt;k: ans=k idx=i return s[idx:idx+ans] 优化 | $manacher$算法 比较有难度,参考罗勇军老师的《算法竞赛》一书 12345678910111213141516171819202122232425class Solution: def longestPalindrome(self, s: str) -&gt; str: # manacher马拉车 ls=&#x27;#&#x27;+&#x27;#&#x27;.join(list(s))+&#x27;#&#x27; n=len(ls) p=[1]*n #改进一下 --&gt;初始化为1 即可 r,c=0,0 ans,idx=0,0 for i in range(1,n): if i&lt;r: p[i]=min(p[2*c-i],c+p[c]-i) # 暴力中心扩散 while i+p[i]&lt;n and i-p[i]&gt;=0 and ls[i+p[i]]==ls[i-p[i]]:p[i]+=1 # 更新回文中心即可 if i+p[i]&gt;r: r=i+p[i] c=i # 用作数据统计分析 if p[i]&gt;ans: ans,idx=p[i],i ans-=1 st=(idx-ans)//2 return s[st:st+ans]","categories":["算法学习","回文串"]},{"path":"/2023/01/16/前缀树/","content":"字典树 | 笔记整理! 字典树实现 | 数组 + 字典(哈希表)208.实现 Trie (前缀树) 数组存储1234567891011121314151617181920212223242526272829class Trie(): def __init__(self) -&gt; None: self.d=[0]*26 self.flag=False def insert(self,words): node=self for i in words: i=ord(i)-ord(&#x27;a&#x27;) if node.d[i]==0: node.d[i]=Trie() node=node.d[i] node.flag=True def search(self,words): node=self.search_prefix(words) return node!=None and node.flag def search_prefix(self,words): node=self for i in words: i=ord(i)-ord(&#x27;a&#x27;) if node.d[i]==0: return None node=node.d[i] return node def startsWith(self,words): return self.search_prefix(words)!=None 哈希表(字典)存储1234567891011121314151617181920212223242526272829class Trie: def __init__(self): self.d=defaultdict(int) self.tag=False def insert(self, word: str) -&gt; None: node=self for i in word: v=ord(i)-ord(&#x27;a&#x27;) if not node.d[v]: node.d[v]=Trie() node=node.d[v] node.tag=True def search_prefix(self, word: str) -&gt; bool: node=self for i in word: v=ord(i)-ord(&#x27;a&#x27;) if not node.d[v]: return None node=node.d[v] return node def search(self,word): node=self.search_prefix(word) return node is not None and node.tag def startsWith(self, prefix: str) -&gt; bool: return self.search_prefix(prefix) is not None 应用判断前缀和14. 最长公共前缀 暴力 | 强行操作即可123456789101112class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: def helper(x,y): i=0 while i&lt;len(x) and i&lt;len(y) and x[i]==y[i]: i+=1 return x[:i] n=len(strs) ans=strs[0] for i in range(1,n): ans=helper(ans,strs[i]) return ans 分治 | 参考归并排序 (合并k个链表)12345678910111213141516class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: ### 分治思想 def helper(l,r): if l&gt;=r: return strs[l] mid=l+r&gt;&gt;1 l=helper(l,mid) r=helper(mid+1,r) k=min(len(l),len(r)) for i in range(k): if l[i]!=r[i]: k=i break return l[:k] return helper(0,len(strs)-1) 前缀树 | 存储 字符即可123456789101112131415161718192021222324252627class Trie: def __init__(self): self.d=defaultdict(int) self.tag=False def insert(self, word: str) -&gt; None: node=self for v in word: if not node.d[v]: node.d[v]=Trie() node=node.d[v] node.tag=True def search(self, word: str) -&gt; bool: node=self ans=&#x27;&#x27; for v in word: ### 遇到分治或是到达低端 就判断即可! if len(node.d)&gt;1 or node.tag: return ans if v in node.d: ans+=v node=node.d[v] return ansclass Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: t=Trie() for i in strs:t.insert(i) return t.search(strs[0])","categories":["算法学习","树","字符串"]},{"path":"/2023/01/13/有趣的题/","content":"好题 | 笔记整理! 链表+ 树(层次遍历) | bfs +dfs | 心得面试题 04.03. 特定深度节点链表 bfs | 借助队列处理 常规处理 1234567891011121314151617class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: q=[tree] ans=[] while q: sz=len(q) pre=x=ListNode() for i in range(sz): node=q[0] del q[0] x.next=ListNode(node.val) x=x.next if node.left:q.append(node.left) if node.right:q.append(node.right) x.next=None ans.append(pre.next) return ans dfs | 先left | 先right 受树层次遍历启发! 先left处理 | 插入节点是在末位 并不是很常见 12345678910111213141516171819# 先left处理时候 插入节点是在链表末位插入class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append(ListNode(root.val)) else: pre=ans[level] # 末位处理|找到链表结尾部分 while pre.next:pre=pre.next pre.next=cur pre=pre.next dfs(root.left,level+1) dfs(root.right,level+1) dfs(tree,0) return ans 可以存储末位部分 略有优化 123456789101112131415class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append([cur,cur]) else: ans[level][-1].next=cur ans[level][-1]=ans[level][-1].next dfs(root.left,level+1) dfs(root.right,level+1) dfs(tree,0) return [k for k,_ in ans] 先right处理 | 直接尾插法即可2326. 螺旋矩阵 IV 比较容易 123456789101112131415class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append(cur) else: cur.next=ans[level] ans[level]=cur dfs(root.right,level+1) dfs(root.left,level+1) dfs(tree,0) return ans 螺旋数组 | 笔记心得暴力破解 | 只能暴力找规律 过于漫长! 123456789101112131415161718192021222324252627282930313233class Solution: def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -&gt; List[List[int]]: ls=[[-1 for _ in range(n)] for _ in range(m)] l,r=0,n-1 t,d=0,m-1 while head: # 向左移动 i,j=t,l while j&lt;=r and head: ls[i][j]=head.val head=head.next j+=1 t+=1 i,j=t,r # 向下走 while i&lt;=d and head: ls[i][j]=head.val head=head.next i+=1 r-=1 i,j=d,r while j&gt;=l and head: ls[i][j]=head.val head=head.next j-=1 d-=1 i,j=d,l while i&gt;=t and head: ls[i][j]=head.val head=head.next i-=1 l+=1 return ls 逻辑优化一下 | 试试看 借鉴大佬 | 确实6 1234567891011121314151617class Solution: def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -&gt; List[List[int]]: ans=[[-1]*n for _ in range(m)] # 模拟右下左上 d=[[0,1],[1,0],[0,-1],[-1,0]] idx=0 cur=[0,0] while head: l,r=cur ans[l][r]=head.val i,j=d[idx] if not 0&lt;=l+i&lt;m or not 0&lt;=r+j&lt;n or ans[l+i][r+j]!=-1: idx=(idx+1)%4 i,j=d[idx] cur=[l+i,r+j] head=head.next return ans","categories":["算法学习","有趣的题"]},{"path":"/2023/01/13/链表/","content":"链表 | 笔记整理! 算法竞赛 | 例题:约瑟夫 算法竞赛例题 | 洛谷 P1996 约瑟夫问题 题目# P1996 约瑟夫问题 求解数组 | 标记 模拟12345678910111213m,n=map(int,input().split())flag=[0]*(m+1)idx=0for i in range(m):\tj=0\twhile j&lt;n: idx+=1 if idx&gt;m:idx=1 if flag[idx]:j-=1 j+=1\tprint(idx,end=&#x27; &#x27;)\tflag[idx]=1 单链表处理1234567891011121314151617181920212223m,n=map(int,input().split())class LinkNode():\tdef __init__(self,val=0,next=None) -&gt; None: self.val=val self.next=nextnode=cur=Nonefor i in range(1,m+1):\tif i==1: cur=node=LinkNode(i)\telse: cur.next=LinkNode(i) cur=cur.nextcur.next=nodehead=prev=nodefor _ in range(m):\tfor _ in range(1,n): prev=head head=head.next\tprint(head.val,end=&#x27; &#x27;)\tprev.next=head.next\thead=prev.next 静态链表处理123456789101112131415m,n=map(int,input().split())node=[0]*(m+1)for i in range(1,m):\tnode[i]=i+1node[m]=1prev=head=1for _ in range(m):\tfor _ in range(1,n): prev=head head=node[head]\tprint(head,end=&#x27; &#x27;)\tnode[prev]=node[head]\thead=node[prev] 力扣刷题 | 部分经典题目 部分总结归纳 dfs做法 | 笔记整理在另一篇面试题 04.03. 特定深度节点链表 123456789101112131415class Solution: def listOfDepth(self, tree: TreeNode) -&gt; List[ListNode]: ans=[] def dfs(root,level): if not root:return cur=ListNode(root.val) if len(ans)==level: ans.append(cur) else: cur.next=ans[level] ans[level]=cur dfs(root.right,level+1) dfs(root.left,level+1) dfs(tree,0) return ans 模拟加减运算链表求和 12345678910111213141516171819class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: def cal_ans(l1,l2): flag=0 head=ans=ListNode() while l1 or l2: x=l1.val if l1 else 0 y=l2.val if l2 else 0 s=x+y+flag flag=s//10 cur=ListNode(s%10) ans.next=cur ans=ans.next if l1:l1=l1.next if l2:l2=l2.next if flag: ans.next=ListNode(1) return head.next return cal_ans(l1,l2) 环路检测 问题 set集合检测 | 环装归纳 环路检测 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def detectCycle(self, head: ListNode) -&gt; ListNode: # 经典做法就是 用set来存储 然后进行检测 # 优化方案--&gt;快慢指针(叫双指针也行) # b是环的起点到相遇的地方(c的开始)--&gt;故相遇之后a==c # 原理推导 a+n(b+c)+b==2(a+b)--&gt;a=(n-1)b+cn #--&gt;a=c+(n-1)(b+c) (b+c是环) fast=slow=head while fast: slow=slow.next if fast.next: fast=fast.next.next else: return None if fast==slow: while head!=slow: head=head.next slow=slow.next return head return None 链表 + 前缀和从链表中删去总和值为零的连续节点 12345678910111213141516171819# 使用dict来存储,第一次遍历会覆盖重复的pre保留为最后一次的class Solution: def removeZeroSumSublists(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: cur=dummpy=ListNode(0,head) pre=0 d=dict() while cur: pre+=cur.val d[pre]=cur cur=cur.next s=0 cur=dummpy while cur: s+=cur.val cur.next=d[s].next cur=cur.next return dummpy.next 经典递归调用 | 树+链表 此处过于精彩! 二叉树中的链表 1234567891011class Solution: def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -&gt; bool: def helper(head,root): if not head:return True if not root:return False if head.val!=root.val: return False return helper(head.next,root.left) or helper(head.next,root.right) # 突破口是 在这里 不断的递归枚举调用! if not root:return False return helper(head,root) or self.isSubPath(head,root.left) or self.isSubPath(head,root.right) 小结 这部分还是比较重要的，如果单纯考链表就比较容易了！","categories":["算法学习","数据结构","链表"]},{"path":"/2023/01/12/堆/","content":"堆| 笔记整理! 思路梳理 | 结构体部分123def __init__(self) -&gt; None: self.heap_list=[0] self.length=0 主体部分是 | 上升和下降上升部分 | 对应的是 插入1234567891011def perc_up(self,i): while i//2&gt;0: # 当前节点是 小于父节点的 if self.heap_list[i]&lt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1def insert(self,k): self.heap_list.append(k) self.length+=1 self.perc_up(self.length) 下降部分 | 对应的是建立 + 删除堆顶元素123456789101112131415161718192021222324252627282930def perc_down(self,i): while i*2&lt;=self.length: idx=self.min_child(i) if self.heap_list[i]&gt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx def min_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&lt;self.heap_list[i*2+1]: return i*2 return i*2+1 def del_min(self): min_val=self.heap_list[1] # self.heap_list[1]=self.heap_list[self.length] # 这样来写也可以id self.heap_list[-1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return min_val def build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1 完整代码 | 关于最大堆+最小堆最大堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class BinaryHeap():\tdef __init__(self): self.heap_list=[0] self.length=0\tdef insert(self,i): self.heap_list.append(i) self.length+=1 self.perc_up(self.length)\tdef perc_up(self,i): while i//2&gt;0: if self.heap_list[i]&gt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1\tdef max_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&gt;self.heap_list[i*2+1]: return i*2 return i*2+1\tdef del_max(self,i): val=self.heap_list[1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return val\tdef perc_down(self,i): while i*2&lt;=self.length: idx=self.max_child(i) if self.heap_list[i]&lt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx\tdef build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1if __name__==&#x27;__main__&#x27;:\tls=[9,5,6,3,2,3,10]\theap=BinaryHeap()\theap.build_heap(ls)\tprint(heap.heap_list) 最小堆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class BinaryHeap(): def __init__(self) -&gt; None: self.heap_list=[0] self.length=0 def perc_up(self,i): while i//2&gt;0: # 当前节点是 小于父节点的 if self.heap_list[i]&lt;self.heap_list[i//2]: self.heap_list[i],self.heap_list[i//2]=self.heap_list[i//2],self.heap_list[i] i&gt;&gt;=1 def insert(self,k): self.heap_list.append(k) self.length+=1 self.perc_up(self.length) def perc_down(self,i): while i*2&lt;=self.length: idx=self.min_child(i) if self.heap_list[i]&gt;self.heap_list[idx]: self.heap_list[i],self.heap_list[idx]=self.heap_list[idx],self.heap_list[i] i=idx def min_child(self,i): if i*2+1&gt;self.length: return i*2 else: if self.heap_list[i*2]&lt;self.heap_list[i*2+1]: return i*2 return i*2+1 def del_min(self): min_val=self.heap_list[1] # self.heap_list[1]=self.heap_list[self.length] # 这样来写也可以id self.heap_list[-1] self.heap_list[1]=self.heap_list.pop() self.length-=1 self.perc_down(1) return min_val def build_heap(self,ls): self.length=len(ls) i=self.length//2 self.heap_list=[0]+ls[:] while i&gt;0: self.perc_down(i) i-=1if __name__==&#x27;__main__&#x27;: ls=[9,6,5,2,3] heap=BinaryHeap() heap.build_heap(ls) print(heap.heap_list)","categories":["算法学习","树","堆"]},{"path":"/2023/01/12/排序/","content":"排序 | 笔记整理! 快速排序123456789101112131415161718192021222324252627282930import numpy as npdef quick_sort(nums,l,r): if l&gt;=r: return # 稍微进行优化! rand=l+np.random.randint(100)%(r-l+1) nums[l],nums[rand]=nums[rand],nums[l] x=nums[l] i,j=l,r while i&lt;j: while i&lt;j and nums[j]&gt;x:j-=1 if i&lt;j: nums[i]=nums[j] i+=1 while i&lt;j and nums[i]&lt;x:i+=1 if i&lt;j: nums[j]=nums[i] j-=1 nums[i]=x quick_sort(nums,l,i-1) quick_sort(nums,i+1,r)if __name__==&#x27;__main__&#x27;: nums=np.random.randint(100,size=12) print(&quot;生成的数组是:&quot;,nums) quick_sort(nums,0,11) print(&quot;排序后数组是:&quot;,nums) 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npdef merge_sort(nums,l,r): if l&gt;=r: return mid=l+r&gt;&gt;1 # 对于 l~mid 和 mid+1~r 进行分别处理 merge_sort(nums,l,mid) merge_sort(nums,mid+1,r) # 此处已经是 处理之后的 结果.进行归并即可! i,j=l,mid+1 idx=0 while i&lt;=mid and j&lt;=r: if nums[i]&lt;=nums[j]: help_ls[idx]=nums[i] i+=1 else: help_ls[idx]=nums[j] j+=1 idx+=1 while i&lt;=mid: help_ls[idx]=nums[i] i+=1 idx+=1 while j&lt;=r: help_ls[idx]=nums[j] j+=1 idx+=1 # 进行复制即可 for i in range(idx): nums[l+i]=help_ls[i]if __name__==&#x27;__main__&#x27;: n=12 nums=np.random.randint(100,size=n) help_ls=[0]*n # 生成辅助数组 print(&quot;生成的数组是:&quot;,nums) merge_sort(nums,0,11) print(&quot;排序后数组是:&quot;,nums) 计数排序 理解记忆 1234567891011121314151617181920212223242526272829303132import numpy as npdef counting_sort(nums): # 进行计数 for i in nums: help_c[i]+=1 # 输出结果 print(&quot;排序后数组是:&quot;,end=&#x27; &#x27;) for i in range(max_val): for j in range(help_c[i]): #需要重复的次数是 print(i,end=&#x27; &#x27;) # 前缀和 for i in range(1,max_val): help_c[i]+=help_c[i-1] for i in range(n-1,-1,-1): help_r[i]=help_c[nums[i]] help_c[nums[i]]-=1 print(&quot; 出现的次序:&quot;,end=&#x27; &#x27;) for i in range(n): print(help_r[i],end=&#x27; &#x27;)if __name__==&#x27;__main__&#x27;: n=12 max_val=10 nums=np.random.randint(max_val,size=n) help_a=[0]*n # 生成辅助数组 help_c=[0]*n # 生成辅助数组 help_r=[0]*n # 生成辅助数组 print(&quot;生成的数组是:&quot;,nums) counting_sort(nums) 基数排序1234567891011121314151617181920212223242526272829303132import numpy as npdef counting_sort(): help_c=[0]*10 # 生成辅助数组 # 进行计数即可 for i in help_v: help_c[i]+=1 # 前缀和 for i in range(1,10): help_c[i]+=help_c[i-1] # 从后开始 这是用help_s用来标记位次顺序 for i in range(n-1,-1,-1): help_r[help_s[i]]=help_c[help_v[help_s[i]]] help_c[help_v[help_s[i]]]-=1 # 记录这次之后的位次顺序 因为是从0开始的 位次是1 for i in range(n): help_s[help_r[i]-1]=iif __name__==&#x27;__main__&#x27;: n=12 max_val=100 nums=np.random.randint(max_val,size=n) help_s=list(range(n)) help_r=[0]*n # 生成辅助数组 help_v=[0]*n # 生成辅助数 x=1 print(&quot;生成的数组是:&quot;,list(nums)) for i in range(2): for j in range(n): help_v[j]=nums[j]//x%10 counting_sort() x*=10 print(&quot;排序后数组是:&quot;,[nums[help_s[i]] for i in range(n)])","categories":["算法学习","排序"]},{"path":"/2023/01/12/字符串/","content":"字符串转换数字 | 笔记整理! 字符串字符串转为数字[]12345678910111213141516# 使用for循环即可! 需要考虑末位class Solution: def areNumbersAscending(self, s: str) -&gt; bool: pre=0 num=0 for i in s: if &#x27;0&#x27;&lt;=i&lt;=&#x27;9&#x27;: num=num*10+ord(i)-ord(&#x27;0&#x27;) else: if num&gt;=1: if pre&gt;=num:return False pre=num num=0 # 需要考虑到末位 if num and pre&gt;=num:return False return True []1234567891011121314151617181920# 使用while遍历即可class Solution: def areNumbersAscending(self, s: str) -&gt; bool: pre=0 n=len(s) i=0 num=0 while i&lt;n: if s[i].isdigit(): while i&lt;n and s[i].isdigit(): num=num*10+ord(s[i])-ord(&#x27;0&#x27;) i+=1 if not pre: pre=num elif pre&gt;=num:return False else:pre=num print(num) num=0 i+=1 return True","categories":["算法学习","字符串"]},{"path":"/2023/01/12/解析树/","content":"解析树| 笔记整理! 笔记心得 参考Python数据结构(外) 结构体部分 | 插入部分是必要的1234567891011121314151617181920class TreeNode: def __init__(self, val=&#x27;&#x27;, left=None, right=None): self.val = val self.left = left self.right = right def insert_left(self,val=&#x27;&#x27;): t=TreeNode(val) if not self.left: self.left=t else: t.left=self.left self.left=t def insert_right(self,val=&#x27;&#x27;): t=TreeNode(val) if not self.right: self.right=t else: t.right=self.right self.right=t 进行建树 | 合理利用栈即可1234567891011121314151617181920212223def build_parse_tree(s): ls=list(s) root=TreeNode() stk=[root] cur=root for i in ls: if i==&#x27;(&#x27;: cur.insert_left() #进行占位 stk.append(cur) cur=cur.left elif i not in &#x27;+-*/)&#x27;: cur.val=int(i) cur=stk.pop() elif i in &#x27;+-*/&#x27;: cur.val=i cur.insert_right() stk.append(cur) cur=cur.right elif i==&#x27;)&#x27;: cur=stk.pop() else: raise ValueError(&quot;当前输入不合法!&quot;) return root 计算解析树 | 递归处理12345678910111213def get_ans(root): map=&#123; &#x27;+&#x27;:lambda x,y:x+y, &#x27;-&#x27;:lambda x,y:x-y, &#x27;*&#x27;:lambda x,y:x*y, &#x27;/&#x27;:lambda x,y:x/y, &#125; l=root.left r=root.right if l and r: return map[root.val](get_ans(l),get_ans(r)) else: return root.val 遍历输出 | 利用中序遍历 这部分不自信 错了滴滴我 原书思路12345def print_exp1(root): ans=&#x27;&#x27; if root: ans=&#x27;(&#x27;+print_exp(root.left)+str(root.val)+print_exp(root.right)+&#x27;)&#x27; return ans 优化12345678def print_exp2(root): ans=&#x27;&#x27; if root: if root.left and root.right: ans=&#x27;(&#x27;+print_exp(root.left)+str(root.val)+print_exp(root.right)+&#x27;)&#x27; else: ans=print_exp(root.left)+str(root.val)+print_exp(root.right) return ans 感觉还可以优化一下 | 根据优先级12345678910111213141516def helper(root,flag): map=&#123; &#x27;+&#x27;:1,&#x27;-&#x27;:1, &#x27;*&#x27;:2,&#x27;/&#x27;:2 &#125; ans=&#x27;&#x27; if root: ans=helper(root.left,flag)+str(root.val)+helper(root.right,flag) if root.left and root.right: if root.val in map and map[root.val]&gt;=flag: flag=map[root.val] ans=helper(root.left,flag)+str(root.val)+helper(root.right,flag) else: ans=&#x27;(&#x27;+ans+&#x27;)&#x27; return ans 感觉不是很难 | 2023.1.12 算法之路 不断精进!","categories":["算法学习","树"]},{"title":"关于","path":"/about/index.html","content":"夏桑就读于克莱登大学，职业写Bug，擅长摸鱼。实验室下班钟点工，精通各种编程技能，如手撕HelloWorld。力扣周赛坐牢冠军，专业认证CV工程师。前面的话都是编的，但说真的，很抱歉，怪遗憾的挺想你的。O(∩_∩)O哈哈~"},{"path":"/notes/index.html","content":"笔记部分"}]